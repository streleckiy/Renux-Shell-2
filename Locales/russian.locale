
// Русская локализация by Streleckiy Development
// Для создания своей локализации скопируйте этот файл в папку %AppData%\by.strdev\locales.
//   Затем переименуйте скопированный файл по формату название_языка.locale (вместо название_языка указываете свое имя языка).

// Все параметры локализации должны иметь свое значение, иначе не указанный параметр будет иметь в себе пустое значение.
//   Формат записи: <ПАРАМЕТР>=<ТЕКСТ>
//   Между знаком "=" (равно) не должно быть пробелов, так как они будут относиться как к параметру, так и к тексту.
// Для перехода на новую строку используйте \n.
// Чтобы оставлять комментарии, ставьте два слэша в начале строки.
// Файл локализации обязательно должен быть с кодировкой ANSI.
// В некоторых местах Renux чувствителен к регистру букв, поэтому их нужно соблюдать даже после перевода.
// Если указано одно слово, то нужно, чтобы после перевода также вводилось одно слово, так как Renux может принимать только одно слово в некоторых случаях. 

// ============================================================================================================================

// В случае непредвиденной ошибки или краша.
RSHELL_ERROR_TITLE=Сессия Renux Shell завершена.
RSHELL_ERROR_IF_SHELL_MODE=\n\n	При исполнении пакетного файла: %1
RSHELL_ERROR_VISIBLE_TEXT=\n	Сессия Renux Shell была принудительна завершена.\n\n	Похоже, что-то вызвало фатальную ошибку в программном коде Renux, которую не предусмотрел разработчик.\n\n	Информация, которая понадобится разработчику: %1.\n\n	Ошибка была вызвана командой: %2
RSHELL_ERROR_VISIBLE_TEXT_BT=\n\n	Попытка отправки информации об ошибке в баг-трекер...
RSHELL_ERROR_BT_SEND_ERROR=\n\n	Не удалось доставить сообщение! Пожалуйста, сообщите разработчику (vk.com/strdev).
RSHELL_ERROR_BT_SEND_SUCCESS=\n\n	Сообщение успешно доставлено разработчику. Спасибо!
RSHELL_ERROR_ATTACHED_CLOSE=\n\n	Программа была автоматически закрыта.

// Текст ошибок при извлечения иконки из .EXE или .DLL файла.
RSHELL_CANT_LOAD_MODULE=Невозможно загрузить указанный модуль!\nОшибка %1
RSHELL_ONLY_DLL_AND_EXE_FILES=Допустимы только dll и exe файлы
RSHELL_FILE_DOES_NOT_FINDED="Файл %1 не найден
RSHELL_ICON_IN_FILE_NOT_FINDED=Иконка %1 в файле %2 не найдена
RSHELL_ICONS_IN_FILE_NOT_FINDED=Иконки в файле %1 не найдены
RSHELL_INVALID_TYPE_FILE=Ресурс %1 неправильного типа. Возможно, файл сжат или зашифрован\nПродолжить?
RSHELL_INCORRECT_RESOURCE=Неправильный ресурс
RSHELL_CANT_CREATE_DIR=Невозможно создать папку %1\nОшибка %2
RSHELL_CANT_OPEN_FILE_TO_WRITE=Невозможно открыть файл %1 на запись\nОшибка %2

// Текст причины блокировки отключения компьютера
RSHELL_BLOCK_SHUTDOWN_TEXT=Подождите. Программа сейчас закроется...

// Текст, если не удалось заблокировать отключение компьютера
RSHELL_CATCH_BLOCK_SHUTDOWN_TEXT=%1 в процессе... Разрешить?

// Текстовая реакция на API Renux Shell
RSHELL_SERVER_API_CATCH_ERROR=Ошибка. Не удалось получить ответ сервера (%1).
RSHELL_SERVER_API_SERVER_RESPONSE_TO_DEBUG=Ответ сервера RS: %1

// Текстовая реакция на API VKontakte
RSHELL_VK_API_CATCH_ERROR=Ошибка. Не удалось получить ответ сервера (VK API).
RSHELL_VK_API_SERVER_RESPONSE_TO_DEBUG=Ответ: %1
RSHELL_VK_API_RESPONSE_IS_EMPTY=Ошибка. Ответ сервера пуст (VK API).

// Текстовая реакция JSON-парсера
RSHELL_JSON_TEXT_BAD_KEY_TO_DEBUG=Плохой ключ: %1
RSHELL_JSON_TEXT_BAD_VALUE=Плохое значение: %1
RSHELL_JSON_TEXT_BAD_JSON_STRING_TO_DEBUG=Плохая JSON-строка: %1

// Текстовая реакция на ошибки перехвата консоли
RSHELL_RUNCON_CANT_CREATE_PROCESS=Не удалось создать процесс.

// Текстовая реакция обработчика команд Renux Shell
RSHELL_PARSER_NEED_WRITE_PARAMETERS=Нужно указать все необходимые параметры, которая принимает эта команда (указано: %1, нужно: %2).

// Текстовая реакция обработчика параметров запуска.
RSHELL_WARNING_PARAM_HIDE=После того, как Renux Shell выполнит команду в фоновом режиме, он закроется.
RSHELL_WARNING_PARAM_AIDE=Вы не можете использовать этот параметр, когда программа уже запущена.
RSHELL_WARNING_PARAM_NEW=Вы не можете использовать этот параметр, когда программа уже запущена.
RSHELL_WARNING_PARAM_NOT_PROCESSED=Аргумент %1 не удалось обработать.
RSHELL_UNABLE_TO_EXECUTE_ERROR_BETA=Невозможно выполнить (программа в режиме бета-тестирования)!

// Интерфейс отладчика
RSHELL_DEBUG_WARNING=Обратите внимание: когда Renux Shell просит ввести данные для обработки, окно отладки перестает отвечать. Это особенность Windows, так что с этим ничего не поделать. Также скорость работы сценариев незначительно снижается.
RSHELL_DEBUG_MENU_NAME=Отладка
RSHELL_DEBUG_GO_TO_LINE=Переход к строке
RSHELL_DEBUG_EXECUTE_CMD=Выполнить команду
RSHELL_DEBUG_PAUSE_CMD=Пауза перед командой
RSHELL_DEBUG_LISTVIEW_TEXT=№ строки|Текст строки|Сообщение
RSHELL_DEBUG_GO_FUNC_SUCCESSFUL=Переход на функцию %1 успешен.
RSHELL_DEBUG_WRITE_NUM_OF_LINE=Укажите номер строки в поле ниже.
RSHELL_DEBUG_GOTO_BUTTON_NAME=Перейти
RSHELL_DEBUG_GOTO_CENTER_TEXT=Переход к строке
RSHELL_DEBUG_GOTO_LINE_SUCCESSFUL=Переход на строку №%1 успешен.
RSHELL_DEBUG_WRITE_COMMAND_TO_EXECUTE=Укажите команду для выполнения.
RSHELL_DEBUG_BUTTON_EXECUTE_NAME=Выполнить
RSHELL_DEBUG_EXECUTECMD_CENTER_TEXT=Выполнить команду

// Обработчик команд
RSHELL_PROCESSCMD_TO_DEBUG=Функция вернула: %1

// Текстовые реакции на выполнение команды
RSHELL_EXECUTECMD_DONT_HAVE_PERMISSION=У Вас недостаточно прав для выполнения данной команды.
RSHELL_EXECUTECMD_START_PROCESS_MSG_TO_DEBUG=Запущен процесс под ID: %1
RSHELL_EXECUTECMD_INVALID_CMD=Не удалось определить команду '%1', используйте 'СПРАВКА' или '?' для открытия справки.
RSHELL_EXECUTECMD_INVALID_CMD_SHELL=Команду '%1' обработать не удалось!
RSHELL_EXECUTECMD_INVALID_CMD_SHELL_MSGBOX=Произошла ошибка при исполнении пакетного файла '%1':\n\nКоманду '%2' обработать не удалось!
RSHELL_EXECUTECMD_OPERATION_SUCCESSFUL=Операция завершена.

// Текстовые реакции Renux Shell Add-on Compiled Unpacker
RSHELL_RSAC_ERROR_WRITE_FILE_RSA=Не удалось записать .rsa файл по пути: %1\%2.rsa
RSHELL_RSAC_ERROR_WRITE_FILE_RS=Не удалось записать .rs файл по пути: %1\%2.rs
RSHELL_RSAC_ERROR_WRITE_FILE_TIP=Попробуйте запустить программу от имени администратора.
RSHELL_RSAC_SUCCESSFULL_INSATALLED=Аддон установлен как %1.rsa!

// Имена встроенных переменных
RSHELL_VARNAME_TIME_DAY=.время.день
RSHELL_VARNAME_TIME_MONTH=.время.месяц
RSHELL_VARNAME_TIME_YEAR=.время.год
RSHELL_VARNAME_TIME_HOUR=.время.час
RSHELL_VARNAME_TIME_MIN=.время.минута
RSHELL_VARNAME_TIME_SEC=.время.секунда
RSHELL_VARNAME_TIME_TICKCOUNT=.время.счетчик
RSHELL_VARNAME_TIME_MMM=.время.месяцк
RSHELL_VARNAME_TIME_MMMM=.время.месяцс
RSHELL_VARNAME_TIME_DDD=.время.неделяк
RSHELL_VARNAME_TIME_DDDD=.время.неделяс
RSHELL_VARNAME_CONSOLE_RESULT=.консоль.результат
RSHELL_VARNAME_CONSOLE_WORKINGDIR=.консоль.рпапка
RSHELL_VARNAME_CONSOLE_SCRIPT=.консоль.скрипт
RSHELL_VARNAME_CONSOLE_SPACE=.консоль.пробел
RSHELL_VARNAME_SYSTEM_CLIPBOARD=.система.клипборд
RSHELL_VARNAME_SCREEN_WIDTH=.экран.ширина
RSHELL_VARNAME_SCREEN_HEIGHT=.экран.высота
RSHELL_VARNAME_CONSOLE_VERSION=.консоль.версия
RSHELL_VARNAME_CONSOLE_ADMIN=.консоль.админ
RSHELL_VARNAME_CONSOLE_ROOTDIR=.консоль.папка
RSHELL_VARNAME_CONSOLE_PATH=.консоль.путь
RSHELL_VARNAME_CONSOLE_NAME=.консоль.имя
RSHELL_VARNAME_CONSOLE_PATHDIR=.консоль.путь.папка
RSHELL_VARNAME_SYSTEM_APPDATA=.система.аппдата
RSHELL_VARNAME_SYSTEM_APPDATACOMMON=.система.оаппдата
RSHELL_VARNAME_SYSTEM_DESKTOP=.система.рстол
RSHELL_VARNAME_SYSTEM_DESKTOPCOMMON=.система.орстол
RSHELL_VARNAME_SYSTEM_IS64BITOS=.система.64бит
RSHELL_VARNAME_SYSTEM_DOCUMENTS=.система.документы
RSHELL_VARNAME_SYSTEM_PROGRAMFILES=.система.прогфайлы
RSHELL_VARNAME_SYSTEM_PROGRAMS=.система.менюпуск
RSHELL_VARNAME_SYSTEM_PROGRAMSCOMMON=.система.оменюпуск
RSHELL_VARNAME_SYSTEM_STARTMENU=.система.стартменю
RSHELL_VARNAME_SYSTEM_STARTMENUCOMMON=.система.остартменю
RSHELL_VARNAME_SYSTEM_STARTUP=.система.автозапуск
RSHELL_VARNAME_SYSTEM_STARTUPCOMMON=.система.оавтозапуск
RSHELL_VARNAME_SYSTEM_OSTYPE=.система.тип
RSHELL_VARNAME_SYSTEM_OSVERSION=.система.версия
RSHELL_VARNAME_SYSTEM_USERNAME=.система.пользователь
RSHELL_VARNAME_SYSTEM_COMPUTERNAME=.система.компьютер
RSHELL_VARNAME_ENVIRONMENT=.окр.%1

// Текстовая реакция при создании переменных или массивов
RSHELL_CATCH_SET_VARIABLE_WARNING=Не удалось назначить переменную '%1' (возможно в названии используются запрещенные символы).
RSHELL_ARRAY_CANT_BE_MULTIDIMENSIONAL=Массив не может быть многомерным.
RSHELL_VARIABLE_NAME_CONTAINS_INVALID_CHARACTERS=Имя переменной содержит недопустимые символы и не может так называться.
RSHELL_ARRAY_NAME_CONTAINS_INVALID_CHARACTERS=Имя массива содержит недопустимые символы и не может так называться.

// Текстовая реакция при подключении Renux Shell не к стандартной консоли Windows.
RSHELL_ATTACH_WARNING_TITLE=: Предупреждение
RSHELL_ATTACH_WARNING_TEXT=Renux Shell может работать некорректно, если в качестве командной строки не используется стандартная командная строка Windows.\n\nЭто предупреждение появилось, так как Renux Shell определил, что Вы запускаете его не напрямую из командной строки, а через: %1 (%2).\n\nНажмите на 'ОК' для продолжения запуска RS.\nНажмите на 'Отмена' для отмены запуска RS.

// Текстовая реакция на просьбу ввода текста в режиме перенаправления вывода.
RSHELL_WOUTPUT_TEXT_TO_DEBUG=Ввод команды отменен, так как идет перенаправление вывода.

// Вывод предупреждения в режиме вывода в MsgBox и в консоль.
RSHELL_WARNING_MSGBOX_FORMAT=%1\n\nОкно автоматически закроется через 5 секунд.
RSHELL_WARNING_CONSOLE_FORMAT=%1

// Вывод информации в режиме вывода в Msgbox и в консоль.
RSHELL_INFORMATION_MSGBOX_FORMAT=%1\n\nОкно автоматически закроется через 5 секунд.
RSHELL_INFORMATION_CONSOLE_FORMAT=[#] %1

// Вывод ошибки в режиме вывода в Msgbox и в консоль.
RSHELL_ERROR_MSGBOX_FORMAT=%1\n\nПродолжить выполнение сценария?
RSHELL_ERROR_CONSOLE_FORMAT=ОШИБКА: %1

// Вывод "вопроса" в консоль.
RSHELL_QUESTION_CONSOLE_FORMAT=[?] %1

// Вывод "прогресса" в консоль.
RSHELL_PROGRESS_CONSOLE_FORMAT=[~] %1

// Текстовая реакция службы скачивания файлов.
RSHELL_DOWNLOADER_FILE_EXIST=Файл по этому пути уже имеется. Сначала удалите его.
RSHELL_DOWNLOADER_GETTING_INFO=Получение информации...
RSHELL_DOWNLOADER_INFO_GET_ERR=определить не удалось
RSHELL_DOWNLOADER_QUESTION_DOWNLOAD=Renux Shell хочет скачать файл %1. Размер: %2. [Y/N]
RSHELL_DOWNLOADER_BYTE_WORD=байт
RSHELL_DOWNLOADER_ATTEMPT=Попытка загрузки файла из Сети Интернет: %1...
RSHELL_DOWNLOADER_ATTEMPT_UNSUCCESSFUL=Файл %1 не удалось скачать.
RSHELL_DOWNLOADER_DOWNLOADED_INFO=Скачано %1 из %2 за %3.
RSHELL_DOWNLOADER_FILE_CORRUPTED=Нарушена целостность файла. Возможно это связано с тем, что у Вас нестабильный интернет.
RSHELL_DOWNLOADER_FILE_TRYAGAIN=Повторить попытку? [Y/N]
RSHELL_DOWNLOADER_DOWNLOADED_INFO_WITHOUT=Скачано %1 за %2.

// Текстовая реакция службы получение размера файла из интернета
RSHELL_FILESIZE_ERROR_TEXT=Ошибка %1
RSHELL_FILESIZE_UNABLE_EXTRACT_ERROR_TEXT=Невозможно извлечь информацию

// Установщик Renux Shell
RSHELL_INSTALLER_DESC=Исполняемый файл Renux Shell
RSHELL_INSTALLER_START_LINK=Запустить Renux Shell
RSHELL_INSTALLER_FAIL_SETUP=Не удалось запустить новую версию программы с приказом установки.\n\nRenux Shell откатил обновление, следовательно, у Вас будет установлена та же версия программы, которая была до установки этой.\n\nПопробуйте повторить попытку обновления программы позже.

// Лаунчер Renux Shell
RSHELL_LAUNCHER_INVALID_NAME=Вы не указали имя программы.
RSHELL_LAUNCHER_NOT_FINDED=Программа %1 не найдена.
RSHELL_LAUNCHER_INIT_START=Инициализация запуска...
RSHELL_LAUNCHER_CHECKING_UPDATES=Проверка наличия новых обновлений...
RSHELL_LAUNCHER_UNABLE_GET_INFO=Не удалось получить информацию с сервера.\n\nНажмите OK, чтобы продолжить запуск программы без проверки обновлений.
RSHELL_LAUNCHER_UPDATING_PREFIX=Обновление
RSHELL_LAUNCHER_UPDATING_PREFIX_FILE_CORRUPTED=Файл поврежден
RSHELL_LAUNCHER_UPDATING_PREFIX_PROCESS=Обновление
RSHELL_LAUNCHER_STARTING=Приложение запускается...
RSHELL_LAUNCHER_START_FAIL=Не удалось запустить файл app.exe: %1
RSHELL_LAUNCHER_ATTEMPT_WORD=Попытка

// Окно с лицензионным соглашением
RSHELL_EULA_CHECKBOX_TEXT1=Я согласен(-а) с пользовательским соглашением.
RSHELL_EULA_TITLE=Пользовательское соглашение
RSHELL_EULA_BUTTON_NEXT=Продолжить

// Инициализация консоли
RSHELL_FROM_UPDATING_TEXT=Программа успешно обновлена.\n
RSHELL_DEBUG_MODE_ENABLED_TEXT=Режим отладки активирован.\n
RSHELL_FIRST_START_TEXT=Вы запустили Renux Shell впервые. Программа выделила себе папку по пути: %1.\n
RSHELL_WARNING_OSVER_NOT_10=Версия Вашего ядра Windows, не совпадает с Windows 10. Возможно, Вы изменили параметры совместимости программы.\n"Renux Shell используются некоторые компоненты системы, существующие и работающие только в Windows 10.\n
RSHELL_WARNING_ANOTHER_VER=Обнаружено, что Вы используете другую версию программы.\nПожалуйста, установите ее, чтобы файлы с расширением *.rs открывались с новыми функциями, которые появились в этой версии.\nИспользуйте 'консоль обновить' с правами администратора для установки этой версии в систему Windows.
RSHELL_START_PROG_WITH_LINK_ON_DESKTOP=Пожалуйста, запускайте Renux Shell через ярлык на рабочем столе.\nНажмите на Y чтобы создать новый ярлык на рабочем столе; N - не создавать.
RSHELL_LINK_SUCCESSFUL_CREATED=Ярлык успешно создан.
RSHELL_REINSTALL_PROGRAM_TEXT=Пожалуйста, переустановите программу. Используйте команду 'консоль установить' с правами администратора.

// Отчет о выполнении стартовой команды в окно отладки
RSHELL_START_CMD_EXECUTED_TO_DEBUG=Выполнение команды завершено.

// Проверка наличия обновлений и обновление
RSHELL_UNABLE_TO_GET_SERVER_INFO=Не удалось определить новейшую версию/ссылку Renux Shell. Работа Renux Shell продолжается...
RSHELL_RELEASED_NEW_VERSION=Появилась новая версия Renux Shell (%1). Текущая версия - %2.\nRenux Shell умеет автоматически обновляться. Обновиться? Y - да; N - нет.\n
RSHELL_PROCESS_OF_UPDATING=Процесс: обновление...
RSHELL_RELEASED_NEW_VERSION_BUT_NOT_INSTALLED=Появилась новая версия Renux Shell (%1). Текущая версия - %2.\nДля установки новой версии в автоматическом режиме необходимо установить программу.\nRenux может автоматически установиться и обновиться. Установить? [Y/N]\n
RSHELL_UNABLE_TO_CHECK_ACTUAL_VERSION=Не удалось проверить наличие новых обновлений. Работа Renux Shell продолжается...

// Просьба пройти обучение
RSHELL_COMPLETE_TUTORIAL=%1, пройдите обучение для того, чтобы Вы могли быстро и максимально производительно работать с данной консолью. Используйте команду "ОБУЧЕНИЕ".\n

// ---
RSHELL_CMD_NOT_EXIST_IN_DOCS=Эта команда в справке отсутствует.
RSHELL_CONHOST_KILLED=Соединение с окном консоли было потеряно. Была создана новая консоль (текущая).\n
RSHELL_TO_ANALYSING_DEBUG=Анализ пакетного файла и запись в память...
RSHELL_UNABLE_OPEN_DOCUMENTATION_ASYNC=Не удалось открыть справку асинхронно.
RSHELL_ARRAY_TOTALLY_WORD=всего
RSHELL_LOCALIZED_WORD_MS=мс
RSHELL_ADMINISTRATOR_WORD=Администратор
RSHELL_EXECUTED_OTHER_LANG=Язык автоматически изменен на совместимый с командой (только в этой сессии использования Renux Shell).

// Окно справка
RSHELL_DOCUMENTATION_WINDOW_TITLE=Руководство по работе с программой Renux Shell
RSHELL_TV_START=Начало работы
RSHELL_TV_START_INFO=Введение
RSHELL_TV_START_TUTORIAL=Обучение
RSHELL_TV_VAR=Встроенные переменные
RSHELL_TV_MAIN=Основное
RSHELL_TV_MAIN_HOTKEYS=Горячие клавиши
RSHELL_TV_MAIN_MACROCOMMANDS=Создание макрокоманды клавиатуры и мыши
RSHELL_TV_MAIN_KEYLIST=Список клавиш и кнопок мыши
RSHELL_TV_MAIN_SCRIPTS=Пакетные файлы
RSHELL_TV_MAIN_VARIABLES=Переменные
RSHELL_TV_ADDONS=Аддоны
RSHELL_TV_ADDONS_QUICKSTART=Введение
RSHELL_TV_ADDONS_CREATING=Создание аддона
RSHELL_TV_ADDONS_COMPILING=Сборка аддона
RSHELL_TV_ADDONS_DELETE=Удаление аддона
RSHELL_TV_CMDS=Список команд
RSHELL_TV_CMDS_CONSOLE=Работа с консолью
RSHELL_TV_CMDS_CNSTCT=Управляющие конструкции
RSHELL_TV_CMDS_KEYBOARD=Управление клавиатурой
RSHELL_TV_CMDS_MOUSE=Управление мышью
RSHELL_TV_CMDS_REG=Управление реестром
RSHELL_TV_CMDS_DIALOG=Диалоговые окна
RSHELL_TV_CMDS_STRINGS=Работа со строками
RSHELL_TV_CMDS_PROCESSES=Управление процессами
RSHELL_TV_CMDS_SOUND=Управление звуком
RSHELL_TV_CMDS_DISPLAY=Работа с экраном
RSHELL_TV_CMDS_WIN=Работа с окнами
RSHELL_TV_CMDS_WIN_ELEM=Работа с элементами окна
RSHELL_TV_CMDS_DIR=Директивы
RSHELL_TV_CMDS_VOICESP=Синтезатор речи
RSHELL_TV_CMDS_NETWORK=Сеть
RSHELL_TV_CMDS_FILE=Файловая система
RSHELL_TV_CMDS_FILE_ATTR=Работа с атрибутами
RSHELL_TV_CMDS_ENV=Управление средой
RSHELL_TV_ABOUTPROG=О программе
RSHELL_TV_UPDATELIST=Список обновлений
RSHELL_TV_UPDATELIST_WORD_VERSION=Версия
RSHELL_TV_UPDATELIST_WORD_FROM=от
RSHELL_TV_ABOUTPROG_TEXT=Информация о программе
RSHELL_ABOUTPROG_TEXT_1=Командная строка Renux Shell.\nВерсия %1.
RSHELL_ABOUTPROG_WORD_DEVELOPED=Разработано
RSHELL_ABOUTPROG_TEXT_2=Многофункциональная командная строка на русском языке "Renux Shell", позволяет автоматизировать почти любые действия в одно нажатие.\nИмеет функционал, разработанный специально для пакетных файлов.\nВ этой версии доступно %1 команд, не учитывая скрытых.
RSHELL_ABOUTPROG_WINDOW_TITLE=Renux Shell: сведения
RSHELL_ABOUTPROG_BUTTON_CLOSE=Закрыть

// НАЗВАНИЯ КОМАНД И ДИРЕКТИВ
RSHELL_COMMAND_NAME_DOWNLOADWITHOUTASK=#СКАЧИВАТЬ_БЕЗ_СПРОСА
RSHELL_COMMAND_NAME_END=КОНЕЦ
RSHELL_COMMAND_NAME_DOCUMENTATION=СПРАВКА
RSHELL_COMMAND_NAME_PROGRAM=ПРОГРАММА
RSHELL_COMMAND_NAME_ADDON=АДДОН
RSHELL_COMMAND_NAME_ADZ=АДЗ
RSHELL_COMMAND_NAME_ADMIN=АДМИН
RSHELL_COMMAND_NAME_UPDATELIST=АПДЕЙТЛИСТ
RSHELL_COMMAND_NAME_ASYNC=АСИНХ
RSHELL_COMMAND_NAME_INPUT=ВВОД
RSHELL_COMMAND_NAME_OUTPUT=ВЫВОД
RSHELL_COMMAND_NAME_OUTPUTL=ВЫВОДБ
RSHELL_COMMAND_NAME_OUTCON=ВЫВОДКОНСОЛЬ || ВК
RSHELL_COMMAND_NAME_TITLE=ЗАГОЛОВОК
RSHELL_COMMAND_NAME_WOUTPUT=ЗВЫВОД
RSHELL_COMMAND_NAME_INFO=ИНФОРМАЦИЯ || ИНФО
RSHELL_COMMAND_NAME_CONSOLE=КОНСОЛЬ
RSHELL_COMMAND_NAME_TUTORIAL=ОБУЧЕНИЕ
RSHELL_COMMAND_NAME_PAUSE=ПАУЗА
RSHELL_COMMAND_NAME_TRANSPARENT=ПРОЗРАЧНОСТЬ
RSHELL_COMMAND_NAME_DO=СДЕЛАТЬ
RSHELL_COMMAND_NAME_SVC=СЛУЖБЫ
RSHELL_COMMAND_NAME_COMPILE=СОБРАТЬ
RSHELL_COMMAND_NAME_CMDLIST=СПИСОК
RSHELL_COMMAND_NAME_DOCS=СПРАВКА || ?
RSHELL_COMMAND_NAME_LABEL=МЕТКА
RSHELL_COMMAND_NAME_GOTO=ПЕРЕЙТИ
RSHELL_COMMAND_NAME_FUNC=ФУНКЦИЯ
RSHELL_COMMAND_NAME_KEYBOARD_INPUT=ВВОДК
RSHELL_COMMAND_NAME_HKEYS=ГК
RSHELL_COMMAND_NAME_WRITE=НАПЕЧАТАТЬ
RSHELL_COMMAND_NAME_WRITEF=НАПЕЧАТАТЬБ
RSHELL_COMMAND_NAME_MOUSE_MOVE=МЫШЬ.ПЕРЕДВИНУТЬ
RSHELL_COMMAND_NAME_REG_WRITE=РЕЕСТР.ЗАПИСАТЬ
RSHELL_COMMAND_NAME_REG_READ=РЕЕСТР.ПРОЧИТАТЬ
RSHELL_COMMAND_NAME_REG_DELETE=РЕЕСТР.УДАЛИТЬ
RSHELL_COMMAND_NAME_DIALOG_INPUTBOX=ВВОД.ОКНО
RSHELL_COMMAND_NAME_MSGBOX=СООБЩЕНИЕ
RSHELL_COMMAND_NAME_JSON=ДЖСОН
RSHELL_COMMAND_NAME_ARR_UNIT=МАССИВ.ОБЪЕДИНИТЬ
RSHELL_COMMAND_NAME_VAR=ПЕР
RSHELL_COMMAND_NAME_STRING_UNUNIT=СТРОКА.РАЗДЕЛИТЬ
RSHELL_COMMAND_NAME_STRING_REPLACE=СТРОКА.ЗАМЕНИТЬ
RSHELL_COMMAND_NAME_EXIT=ВЫХОД
RSHELL_COMMAND_NAME_WAIT_TIME=ЖДАТЬ.ВРЕМЯ
RSHELL_COMMAND_NAME_WAIT_KEY=ЖДАТЬ.НАЖАТИЕ
RSHELL_COMMAND_NAME_CMD=КМД
RSHELL_COMMAND_NAME_PROCESS=ПРОЦЕСС
RSHELL_COMMAND_NAME_PROCESS_SEARCH=ПРОЦЕСС.ИСКАТЬ
RSHELL_COMMAND_NAME_POWERSHELL=ПШ
RSHELL_COMMAND_NAME_RANDOM=РАНД
RSHELL_COMMAND_NAME_RESTART=РЕСТАРТ
RSHELL_COMMAND_NAME_SESSION=СЕССИЯ
RSHELL_COMMAND_NAME_SOUND_SET=ГРОМКОСТЬ
RSHELL_COMMAND_NAME_SOUND_BEEP=ГУДОК
RSHELL_COMMAND_NAME_SOUND_GET=ЗВУКИНФО
RSHELL_COMMAND_NAME_SOUND_PLAY=ПРОИГРАТЬ
RSHELL_COMMAND_NAME_DISPLAY=МОНИТОР
RSHELL_COMMAND_NAME_TOOLTIP=ПОДСКАЗКА
RSHELL_COMMAND_NAME_SCREENSHOT=СКРИНШОТ
RSHELL_COMMAND_NAME_STEXTON=ТЕКСТ.ПОКАЗАТЬ
RSHELL_COMMAND_NAME_STEXTOFF=ТЕКСТ.СКРЫТЬ
RSHELL_COMMAND_NAME_TRAYTIP=УВЕДОМЛЕНИЕ
RSHELL_COMMAND_NAME_BRIGHTNESS=ЯРКОСТЬ
RSHELL_COMMAND_NAME_WIN_ELEM=ОКНО.ЭЛЕМЕНТ
RSHELL_COMMAND_NAME_WIN_ELEM_MOVE=ОКНО.ЭЛЕМЕНТ.ПЕРЕДВИНУТЬ
RSHELL_COMMAND_NAME_WIN_ELEM_VALUE=ОКНО.ЭЛЕМЕНТ.ЗНАЧЕНИЕ
RSHELL_COMMAND_NAME_WIN_ELEM_WRITE=ОКНО.ЭЛЕМЕНТ.НАПЕЧАТАТЬ
RSHELL_COMMAND_NAME_WIN_WAIT=ЖДАТЬ.ОКНО
RSHELL_COMMAND_NAME_WIN_WAIT_ACTIVE=ЖДАТЬ.ОКНО.АКТИВИРОВАТЬ
RSHELL_COMMAND_NAME_WIN_WAIT_DEACTIVE=ЖДАТЬ.ОКНО.ДЕАКТИВИРОВАТЬ
RSHELL_COMMAND_NAME_WIN_WAIT_CLOSE=ЖДАТЬ.ОКНО.ЗАКРЫТИЕ
RSHELL_COMMAND_NAME_WIN_ACTIVATE=ОКНО.АКТИВИРОВАТЬ
RSHELL_COMMAND_NAME_WIN_RESTORE=ОКНО.ВЕРНУТЬ
RSHELL_COMMAND_NAME_WIN_TITLE=ОКНО.ЗАГОЛОВОК
RSHELL_COMMAND_NAME_WIN_CLOSE=ОКНО.ЗАКРЫТЬ
RSHELL_COMMAND_NAME_WIN_SHOW=ОКНО.ПОКАЗАТЬ
RSHELL_COMMAND_NAME_WIN_MAXIMIZE=ОКНО.РАЗВЕРНУТЬ
RSHELL_COMMAND_NAME_WIN_MINIMIZE=ОКНО.СВЕРНУТЬ
RSHELL_COMMAND_NAME_WIN_HIDE=ОКНО.СПРЯТАТЬ
RSHELL_COMMAND_NAME_VOICESP_VOLUME=ГОЛОС.ГРОМКОСТЬ
RSHELL_COMMAND_NAME_VOICESP_SAY=ГОЛОС.СКАЗАТЬ
RSHELL_COMMAND_NAME_VOICESP_SPEED=ГОЛОС.СКОРОСТЬ
RSHELL_COMMAND_NAME_VKAPI=ВКАПИ
RSHELL_COMMAND_NAME_VKAPI_RESET=ВКАПИ.
RSHELL_COMMAND_NAME_REQUEST=ЗАПРОС
RSHELL_COMMAND_NAME_POST=ПОСТ
RSHELL_COMMAND_NAME_CREATEFORMDATA=СОЗДАТЬДАННЫЕФОРМЫ
RSHELL_COMMAND_NAME_NETWORK_SCAN=СЕТЬ.СКАНИРОВАТЬ
RSHELL_COMMAND_NAME_ATTR_GET=АТРИБУТЫ.ПОЛУЧИТЬ
RSHELL_COMMAND_NAME_ATTR_SET=АТРИБУТЫ.УСТАНОВИТЬ
RSHELL_COMMAND_NAME_CD=СД
RSHELL_COMMAND_NAME_CD_DOT=СД. / СД.. / СД...
RSHELL_COMMAND_NAME_DIR=ДИР
RSHELL_COMMAND_NAME_DRIVE=ДИСК.ПРИВОД
RSHELL_COMMAND_NAME_DRIVE_GET=ДИСК.ПОЛУЧИТЬ
RSHELL_COMMAND_NAME_DRIVE_GET_MEMORY=ДИСК.ПОЛУЧИТЬ.СПАМЯТЬ
RSHELL_COMMAND_NAME_INI_WRITE=ИНИ.ЗАПИСАТЬ
RSHELL_COMMAND_NAME_INI_READ=ИНИ.ПРОЧИТАТЬ
RSHELL_COMMAND_NAME_INI_DELETE=ИНИ.УДАЛИТЬ
RSHELL_COMMAND_NAME_ENC_BASE64=КОДИРОВАТЬ.BASE64
RSHELL_COMMAND_NAME_RECYCLE=КОРЗИНА.ПЕРЕМЕСТИТЬ
RSHELL_COMMAND_NAME_RECYCLE_EMPTY=КОРЗИНА.ОЧИСТИТЬ
RSHELL_COMMAND_NAME_PROG=ПРОГ
RSHELL_COMMAND_NAME_DOWNLOAD=СКАЧАТЬ
RSHELL_COMMAND_NAME_FILE_TIME_SET=ФАЙЛ.ВРЕМЯ.УСТАНОВИТЬ
RSHELL_COMMAND_NAME_FILE_TIME_GET=ФАЙЛ.ВРЕМЯ.ПОЛУЧИТЬ
RSHELL_COMMAND_NAME_FILE_WRITE_RAW=ФАЙЛ.ЗАПИСАТЬ.БИНАР
RSHELL_COMMAND_NAME_FILE_SEARCH=ФАЙЛ.ИСКАТЬ
RSHELL_COMMAND_NAME_FILE_ENCODING=ФАЙЛ.КОДИРОВКА
RSHELL_COMMAND_NAME_FILE_MOVE=ФАЙЛ.ПЕРЕМЕСТИТЬ
RSHELL_COMMAND_NAME_FILE_MOVE_DIR=ФАЙЛ.ПЕРЕМЕСТИТЬ.ПАПКА
RSHELL_COMMAND_NAME_FILE_GET=ФАЙЛ.ПОЛУЧИТЬ
RSHELL_COMMAND_NAME_FILE_ADD_LABEL=ФАЙЛ.СОЗДАТЬ.ЯРЛЫК
RSHELL_COMMAND_NAME_FILE_GET_LABEL=ФАЙЛ.ПОЛУЧИТЬ.ЯРЛЫК
RSHELL_COMMAND_NAME_FILE_READ=ФАЙЛ.ПРОЧИТАТЬ
RSHELL_COMMAND_NAME_FILE_READ_RAW=ФАЙЛ.ПРОЧИТАТЬ.БИНАР
RSHELL_COMMAND_NAME_FILE_READ_LINE=ФАЙЛ.ПРОЧИТАТЬ.СТРОКА
RSHELL_COMMAND_NAME_FILE_APPEND=ФАЙЛ.СОЗДАТЬ
RSHELL_COMMAND_NAME_FILE_CREATE_DIR=ФАЙЛ.СОЗДАТЬ.ПАПКА
RSHELL_COMMAND_NAME_FILE_DELETE=ФАЙЛ.УДАЛИТЬ
RSHELL_COMMAND_NAME_FILE_DELETE_DIR=ФАЙЛ.УДАЛИТЬ.ПАПКА
RSHELL_COMMAND_NAME_FILE_COPY=ФАЙЛ.КОПИРОВАТЬ
RSHELL_COMMAND_NAME_FILE_COPY_DIR=ФАЙЛ.КОПИРОВАТЬ.ПАПКА
RSHELL_COMMAND_NAME_FILE_SIZE=ФАЙЛ.РАЗМЕР
RSHELL_COMMAND_NAME_FILE_OUTPUT=ВЫВОДФ
RSHELL_COMMAND_NAME_ENV_UPDATE=ОКРУЖЕНИЕ.ОБНОВИТЬ
RSHELL_COMMAND_NAME_ENV_SET=ОКРУЖЕНИЕ.УСТАНОВИТЬ
RSHELL_COMMAND_NAME_ENV_GET=ОКРУЖЕНИЕ.ПОЛУЧИТЬ
RSHELL_COMMAND_NAME_HIDED_IF=ЕСЛИ
RSHELL_COMMAND_NAME_HIDED_LOOP=ЦИКЛ
RSHELL_COMMAND_NAME_HIDED_FORLOOP=ДЛЯ

// Текст пункта в документации: Введение
RSHELL_DOCS_START_INTRO=Renux Shell - это свободная утилита под Windows с закрытым исходным кодом.\nВы сможете автоматизировать почти все процессы лишь нажатием клавиши или кликом мыши.\nНачать возможно, будет даже легче, чем вы думаете. Прочитайте раздел "Краткое обучение".

// Окно обучения
RSHELL_LEARN_TEXT_PREFIX_LEARN_WORD=Обучение
RSHELL_LEARN_TEXT_TITLE=Обучение Renux Shell
RSHELL_LEARN_TEXT_SUBTITLE=Пройдя это обучение Вы научитесь работать в Renux Shell. Здесь Вы сможете изучить теорию и попробовать себя на практике.
RSHELL_LEARN_TEXT_BUTTON_NEXT=Далее
RSHELL_LEARN_TEXT_PAGE_1=Renux Shell - это многофункциональная командная строка на русском языке и командами. Вы сможете управлять файловой системой, отправлять запросы в Интернет, создавать реакции при нажатии на горячие клавиши, изменять системные настройки, имитировать нажатия клавиш и кнопок мыши, работать с окнами и их элементами, работать с процессами системы, выводить диалоговые окна и это еще не все. Программа умеет выполнять пакетные файлы, которые написаны на языке этой командной строки.
RSHELL_LEARN_TEXT_PAGE_2=Изначально программа находится в портативном режиме (один *.exe файл), однако, это блокирует некоторые ее возможности. Вы можете полностью установить Renux Shell на Ваш компьютер с помощью команды "консоль установить", и также удалить его через команду "консоль удалить". Во время установки программа добавляет себя в переменные окружения и создает ярлыки на рабочем столе и в меню Пуск. Таким образом, Вы сможете выполнять команды Renux Shell прямо из командной строки Windows.
RSHELL_LEARN_TEXT_FIRST_STEPS=Первые шаги
RSHELL_LEARN_TEXT_PAGE_3=Как и все языки программирования, Renux Shell имеет свой синтаксис команд, который чем-то похож на обычную командную строку Windows. Он не очень сложен. Чтобы программа понимала, что от нее требуется, в ней есть встроенные команды, а эти самые команды принимают "параметры". У каждой команды разное количество принимаемых ей параметров. Также параметры чаще всего называют аргументами. Вы можете выводить сообщения в консоль с помощью команд "ВЫВОД" и "ВЫВОДБ" (последний вариант команды отличается лишь тем, что после текста нет перехода на новую строку).
RSHELL_LEARN_TEXT_SYNTAX_AND_FIRST_COMMANDS=Синтаксис и первые команды
RSHELL_LEARN_TEXT_PAGE_4=Давайте попробуем вывести сообщение "Привет, мир". Напишите команду "вывод Привет, мир" в поле ниже.
RSHELL_LEARN_TEXT_NEED_TEXT_4=вывод привет, мир
RSHELL_LEARN_TEXT_IF_WRITED=Отлично, теперь попробуем выполнить эту команду в консоли. Нажмите на кнопку "Далее".
RSHELL_LEARN_TEXT_FIRST_COMMANDS=Первые команды
RSHELL_LEARN_TEXT_PROCESS_CMD=Выполнение команды "%1"...
RSHELL_LEARN_TEXT_SYNTAX_FEATURES_1=Особенности синтаксиса (1/4)
RSHELL_LEARN_TEXT_PAGE_5=Если команда принимает только один параметр, то указывать его в кавычках не нужно, так как они войдут в этот параметр с ним.\n\nЕсли команда принимает несколько параметров (больше одного), то в качестве "разделителя границ" параметров служат одинарные или двойные кавычки. Если параметр состоит из одного слова, то ставить кавычки по обе его стороны не обязательно.
RSHELL_LEARN_TEXT_SYNTAX_FEATURES_2=Особенности синтаксиса (2/4)
RSHELL_LEARN_TEXT_PAGE_6=Пример с командой, которая принимает лишь один параметр:\nвывод Эта команда принимает один параметр, кавычки ставить не нужно.\n\nПример с командой, которая принимает несколько параметров (они разделены двойными кавычками):\nпроцесс "завершить" "explorer.exe"
RSHELL_LEARN_TEXT_SYNTAX_FEATURES_3=Особенности синтаксиса (3/4)
RSHELL_LEARN_TEXT_PAGE_7=Пример с командой, которая принимает несколько параметров (разделены одинарными кавычками):\nпроцесс 'завершить' 'explorer.exe'\n\nПример с командой, которая принимает несколько параметров (разделены одинарными и двойными кавычками):\nпроцесс "завершить' 'explorer.exe"
RSHELL_LEARN_TEXT_SYNTAX_FEATURES_4=Особенности синтаксиса (4/4)
RSHELL_LEARN_TEXT_PAGE_8=Пример с командой, которая принимает несколько параметров (разделены пробелами):\nпроцесс завершить explorer.exe
RSHELL_LEARN_TEXT_SYNTAX_PRACTICE=Практика синтаксиса
RSHELL_LEARN_TEXT_PAGE_9=Вы можете наглядно увидеть, как обрабатываются команды с одним параметром.
RSHELL_LEARN_TEXT_PAGE_9_SUBTITLE_FORMAT=Команда - %1\nПараметр - %2
RSHELL_LEARN_TEXT_AUTOWRITE_PAGE_9=команда текст
RSHELL_LEARN_TEXT_PAGE_10=Вы можете наглядно увидеть, как обрабатываются команды с 10 параметрами. Обработанная информация указана в подсказке под курсором мыши.
RSHELL_LEARN_TEXT_FORMAT_TOOLTIP=Команда: %1.\n1-й параметр: %2.\n2-й параметр: %3.\n3-й параметр: %4.\n4-й параметр: %5.\n5-й параметр: %6.\n6-й параметр: %7.\n7-й параметр: %8.\n8-й параметр: %9.\n9-й параметр: %10.\n10-й параметр: %11.
RSHELL_LEARN_TEXT_PAGE_11=Вы можете посмотреть список всех доступных команд в этой версии в консольном или интерфейсном виде. Для открытия списка команд в консоли, напишите команду "СПИСОК". Для открытия списка команд и справки, используйте "СПРАВКА". В справке присутствует подробная информация о том, как правильно использовать заинтересовавшую Вас команду. Также, в справке Вы можете посмотреть список встроенных переменных, списки обновлений.
RSHELL_LEARN_TEXT_USAGE_TEXT=Руководство по использованию
RSHELL_LEARN_TEXT_BUILTIN_VARS_1=Встроенные переменные (1/2)
RSHELL_LEARN_TEXT_BUILTIN_VARS_2=Встроенные переменные (2/2)
RSHELL_LEARN_TEXT_PAGE_12=Переменными являются участки памяти, где хранятся значения. Значение (или строка, как его иногда называют) может представлять собой любую последовательность символов или цифр. Хотя между текстом и числами не делается никаких различий (и то и другое хранится в виде строк), в некоторых контекстах трактовка строки, полностью состоящей из чисел, отличается от трактовки других строк. Все переменные являются глобальными. Кроме того, переменные не объявляются явно, а появляются автоматически. В примере, приведенном ниже, показано, как присвоить переменной значение:\nпер МояПеременная = 123абв
RSHELL_LEARN_TEXT_PAGE_13=Чтобы позднее извлечь содержимое этой переменной, сошлитесь на нее, поместив ее имя между знаками процента:\nсообщение "" "" "Значение переменной МояПеременная - %МояПеременная%." ""\n\nОбратите внимание, что переменные чувствительны к "РеГиСтРу".
RSHELL_LEARN_TEXT_USEFUL_SYNTAX_FUNCTIONS=Полезные функции синтаксиса
RSHELL_LEARN_TEXT_PAGE_14=Чтобы вместить две команды на одну строку, Вы можете разделять их знаком "точка с запятой" (;). Выполняться будет также, как будто эти команды написаны построчно. Обратите внимание, что с командами "МЕТКА", "ФУНКЦИЯ" разделение восприниматься не будет. Пример:\nвывод Сообщение1; вывод Сообщение 2
RSHELL_LEARN_TEXT_ESCAPE_SEQUENCES=Escape-последовательности
RSHELL_LEARN_TEXT_PAGE_15=Экранирующий символ используется, чтобы показать, что символ, идущий сразу за ним, должен интерпретироваться не так, как обычно. Чтобы экранировать символ, перед ним нужно написать знак "`".\n`` - отображается только один символ "`".\n`% - отображает знак процента принудительно.\n`; - отображает знак ";", вместо разделения строки.\n`n - перевод строки (LF).\n`t - горизонтальная табуляция.
RSHELL_LEARN_TEXT_PAGE_BATCH_FILES=Пакетные файлы
RSHELL_LEARN_TEXT_PAGE_16=Эта возможность открывается после установки консоли через команду "консоль установить". Вы можете создавать файлы с расширением ".rs" в конце, записать в него команды разделяя их новой строкой, поставить кодировку ANSI (обязательно!) и запустить его. Откроется Renux Shell и будет выполнять эти команды построчно. Специально для пакетных файлов созданы отдельные команды. Для редактирования пакетных файлов создана интегрированная среда разработки пользователем hack1exe. Ее можно установить автоматически через команду "ПРОГ".
RSHELL_LEARN_TEXT_COMMANDS_FOR_BATCH_FILES=Команды для пакетных файлов
RSHELL_LEARN_TEXT_PAGE_17=Для пакетных файлов существуют следующие команды - "МЕТКА", "ФУНКЦИЯ", "ПЕРЕЙТИ". Они предоставляют возможность выполнять одни и те же части алгоритма. Подробнее про них можно прочитать в справке. Для быстрого открытия справки про эти команды можно воспользоваться командами "МЕТКА?", "ФУНКЦИЯ?", "ПЕРЕЙТИ?".
RSHELL_LEARN_TEXT_LOOPS_1=Циклы (1/3)
RSHELL_LEARN_TEXT_PAGE_18=Циклы дают возможность повторять выполнение команд(-ы) несколько или бесконечно раз. Для этих операция можно использовать команды "МЕТКА" и "ПЕРЕЙТИ" (но это будет работать только в пакетных файлах). Есть и альтернатива - команда, которая называется "ЦИКЛ", она работает и везде. Сейчас мы рассмотрим команду "ЦИКЛ". Формат записи команды:\nцикл [кол-во повторений:] <команда или команды>\nЕсли нужно повторять команду бесконечное количество раз, то можно использовать эту запись:\nцикл: вывод Этот текст будет выводиться бесконечное количество раз.
RSHELL_LEARN_TEXT_LOOPS_2=Циклы (2/3)
RSHELL_LEARN_TEXT_PAGE_19=Если нужно повторять команду, например, 10 раз, то можно использовать эту запись:\nцикл 10: вывод Этот текст будет выводиться 10 раз.\nНапример, если нужно посчитать до ста, то можно использовать эту запись:\nпер а = 0; цикл 100: пер число += 1; вывод %число%.\nЕсли Вы задаетесь вопросом, почему знак ";" экранирован: если знак не экранировать, то выполнение команды "вывод..." будет относиться не к циклу, а будет выполняться после него.
RSHELL_LEARN_TEXT_LOOPS_3=Циклы (3/3)
RSHELL_LEARN_TEXT_PAGE_20=Теперь рассмотрим команды "МЕТКА" и "ПЕРЕЙТИ". С помощью команды "МЕТКА" мы можем указать именную точку в алгоритме, к которой можно будет вернуться с помощью команды "ПЕРЕЙТИ". Например, если объявлена метка "тест", то вы можете вернуться к ней и выполнить команды, которые были указаны после нее. Вернуться можно будет с помощью команды "перейти тест". Пример ниже:\nметка тест:\nвывод Я работаю; вывод Теперь этот текст должен будет показаться снова.\nперейти тест
RSHELL_LEARN_TEXT_ARRAY_1=Массивы (1/2)
RSHELL_LEARN_TEXT_PAGE_21=Некоторые команды после их выполнения генерируют массивы, в которых храняться данные. Вы можете создать свой массив с помощью команды "ПЕР". Пример:\nпер название_массива[его_индекс] = значение\n\nЧтобы извлечь значение массива, с конкретным индексом, Вы также воспользоваться знаками процента (%), как и с переменными. Пример с выводом значения в консоль:\nвывод %название_массива[его_индекс]%\n
RSHELL_LEARN_TEXT_ARRAY_2=Массивы (2/2)
RSHELL_LEARN_TEXT_PAGE_22=Вы можете также объединить все элементы массива в одну переменную с помощью команды "МАССИВ.ОБЪЕДИНИТЬ". Например, если массив имеет следующие значения:\nмассив[0] == тест\nмассив[1] == иров\nмассив[2] == ание\n\nТо после объединения массива получится переменная со значением "тестирование".
RSHELL_LEARN_TEXT_LIST_OF_VARS_AND_ARRAYS=Просмотр списка переменных и массивов
RSHELL_LEARN_TEXT_PAGE_23=Вы можете посмотреть список объявленных переменных и массивов введя лишь одну команду - "ПЕР СПИСОК". Это открывает множество возможностей для отладки Вашего алгоритма, если Вы пишите пакетный файл. Также, Вы можете использовать команду "АДЗ /DEBUG" или прописать путь к пакетному файлу и после пробела указать параметр /DEBUG. Это откроет Ваш пакетный файл в режиме отладки, с помощью которого Вы сможете перемещаться по строкам пакетного файла и выполнять дополнительные команды, которые не были вписаны в пакетном файле.
RSHELL_LEARN_TEXT_PRACTICE_LOOPS=Практика: циклы
RSHELL_LEARN_TEXT_PAGE_24=Попробуйте написать программу, которая 15 раз выведет слово "привет" в консоль. Подсказка:\n- Команда "вывод" используется для вывода слова текста в консоль.\n- Команда "цикл" позволяет повторять одни и те же действия несколько раз. В нашем случае нужно повторить 15 раз.\nПеред Вами открылся блокнот, в котором нужно ввести команды для того, чтобы выполнить это практическое задание. Для того, чтобы проверить правильность выполнения просто сохраняйте файл.
RSHELL_LEARN_TEXT_NEED_TEXT_PAGE_24_LOW=привет
RSHELL_LEARN_TEXT_PRACTICE_LOOP_LOOP1_TOOLTIP=Подготовка к проверке...
RSHELL_LEARN_TEXT_DONT_USE_COMMENTS_IN_PRACTICE=Не используйте комментарии на практике.
RSHELL_LEARN_TEXT_ALGORITHM_IS_EMPTY=Алгоритм пустой.
RSHELL_LEARN_TEXT_WAIT_REWRITING_FILE=Подождите, идет перезапись %1...
RSHELL_LEARN_TEXT_PREPARING_TO_EXECUTE=Подготовка к исполнению...
RSHELL_LEARN_TEXT_ERROR_WORD=Ошибка
RSHELL_LEARN_TEXT_CANT_CHECK_PRACTICE=К сожалению, не удалось проверить практику.
RSHELL_LEARN_TEXT_WAIT_PROCESS_CHECK_ALGORITHM=Подождите, идет процесс проверки вашего алгоритма...
RSHELL_LEARN_TEXT_LOG_IS_EMPTY=Лог пустой.
RSHELL_LEARN_TEXT_ERROR_PAGE_24_1=Вы вывели 15 раз сообщение "привет", однако не воспользовались командой "ЦИКЛ". Пожалуйста, воспользуйтесь ей.
RSHELL_LEARN_TEXT_COMPLETE_PAGE_24=Вы справились с задачей как нужно.
RSHELL_LEARN_TEXT_ERROR_PAGE_24_2=Нужно вывести сообщение "привет" в консоль 15 раз. Попробуйте еще раз.
RSHELL_LEARN_TEXT_FORLOOP_1=Цикл-for ("для") (1/2)
RSHELL_LEARN_TEXT_PAGE_25=Команда "ДЛЯ" действует почти потому же алгоритму, как "ЦИКЛ", но вместо того чтобы просто повторять действия, эта команда: один раз повторяет указанную Вами команду для каждой пары "ключ-значение" в массиве. Например, если массив содержит:\n"массив[0]" содержит "привет"\n"массив[1]" содержит "мир"\n"массив[логин]" содержит "админ"\n"массив[пароль]" содержит "пароль"
RSHELL_LEARN_TEXT_FORLOOP_2=Цикл-for ("для") (2/2)
RSHELL_LEARN_TEXT_PAGE_26=Благодаря команде "ДЛЯ" Вы сможете вывести все [ключи] и значения в массиве. Формат команды:\n\nдля <имя переменной, в которую запишется ключ> <имя переменной, в которую запишется значение> в <имя массива> сделать <команды>\n\nНапример, мы можем вывести все ключи с их значениями используя эту запись:\nдля ключ значение в массив сделать вывод %ключ% == %значение%
RSHELL_LEARN_TEXT_PRACTICE_FORLOOP=Практика: for-цикл ("для")
RSHELL_LEARN_TEXT_PAGE_27=Попробуйте написать программу, которая выведет все ключи с их значениями в массиве "массив".
RSHELL_LEARN_TEXT_FORLOOP_NAME_OF_ARRAY=массив
RSHELL_LEARN_TEXT_FORLOOP_TOOLTIP_1_NEED_WRITE=для
RSHELL_LEARN_TEXT_FORLOOP_TOOLTIP_1_TEXT=Ваши мысли идут по верному пути. Дополнительный критерий:\n- В команде "для" используйте переменную "к" для вывода ключа массива.\n- В команде "для" используйте переменную "з" для вывода значения массива.
RSHELL_LEARN_TEXT_FORLOOP_TOOLTIP_2_NEED_WRITE=для к з в массив сделать
RSHELL_LEARN_TEXT_FORLOOP_TOOLTIP_2_TEXT=Ваши мысли идут по верному пути. Дополнительный критерий:\n- Следует выводить ключи и значения в консоль по формату: ключ == значение.
RSHELL_LEARN_TEXT_FORLOOP_TOOLTIP_NEED_WRITE=для к з в массив сделать вывод %к% == %з%
RSHELL_LEARN_TEXT_SUCCESSFUL_TEXT=Задача выполнена. Переходите на следующую страницу обучения.
RSHELL_LEARN_TEXT_PAGE_28=Проверим Ваш алгоритм, который Вы написали на практике через %1 секунд...
RSHELL_LEARN_TEXT_WAIT_EXECUTING_ALGORITHM=Ожидание выполнения алгоритма...
RSHELL_LEARN_TEXT_COMMENTS_IN_ALORIGHM_IN_BATCH_FILES=Комментарии в алгоритме (в пакет. файлах)
RSHELL_LEARN_TEXT_PAGE_29=Когда нужно оставить в алгоритме строчку с пояснением - на помощь приходит комментарий, по умолчанию он определяется двумя слэшами.\nСтоит учесть, что для комментирования строк, слэши ставятся только в начале их строк. Пример кода: вывод Это сообщение выводится.\n// это комментарий, Renux Shell пропускает эту строку\nвывод // это сообщение все равно выводится в консоль, так как слэши должны стоять в начале строки.\n// вывод Это сообщение не выводится, так как Renux Shell считает, что это комментарий по двум слэшам в начале команды.
RSHELL_LEARN_TEXT_HKEYS_IN_BATCH_FILES=Горячие клавиши (в пакет. файлах)
RSHELL_LEARN_TEXT_PAGE_30=С помощью Renux Shell Вы можете создавать свои макросы. Перед двоеточием указывается "гк ", затем клавиша или сочетание клавиш через запятую, вызывающие действие:\n  гк Alt,1:\n  вывод Вы нажали на Alt,1\n  ждать.время 5000\n  конец\nПосле действий горячей клавиши нужно указать слово "конец", чтобы программа не продолжала выполнять сценарий дальше.
RSHELL_LEARN_TEXT_EMUL_KEYBOARD_IN_BATCH_FILES=Эмуляция нажатий (в пакет. файлах)
RSHELL_LEARN_TEXT_PAGE_31=Для эмуляции нажатий и ввода текста используется команда "напечатать".\nОна имеет несколько вариаций: напечатать, напечататьб. Подробно про их отличия можно прочитать в справке по этим командам.\n  // Ввод строки по нажатию 1\n  гк 1:\n  напечатать Здравствуйте, чем могу вам помочь?{Enter}Текст с новой строки\n  конец
RSHELL_LEARN_TEXT_NOTES_ABOUT_VARS_1=Примечания по поводу переменных (1/2)
RSHELL_LEARN_TEXT_PAGE_32=Для хранения и обработки информации служат переменные. Во вступительном гайде мы рассмотрим лишь два вида: числовой и текстовый. Переменные в Renux Shell динамически изменяют свой тип в зависимости от последнего присвоенного значения. Имя переменной не должно превышать 254 знаков, может состоять из букв, цифр и знаков # _ @ $ ? [ ]. Вопреки традициям других языков, в ренуксе имена переменных могут начинаться с цифр и даже содержать кириллицу. Логический (булевый) тип предназначен для хранения 1 или 0 (true или false). Числовой тип, как не сложно догадаться, применяется для операций с числами.
RSHELL_LEARN_TEXT_NOTES_ABOUT_VARS_2=Примечания по поводу переменных (2/2)
RSHELL_LEARN_TEXT_PAGE_33=Поддерживается большинство арифметических операций, а так же десятичные дроби. Строковый тип хранит отдельные символы или фрагменты текста. Работа со строками немного отличается от цифровых и булевых переменных- для них есть целый ряд специальных строковых функций. Подр. см. в справке по команде "ПЕР", или использовать команду "ПЕР?" в консоли.
RSHELL_LEARN_TEXT_LOGIC_OPERATIONS_1=Логические операции (1/3)
RSHELL_LEARN_TEXT_PAGE_34=Наверняка вы уже задумались, как выполнять действие только при соблюдении конкретного условия? На помощь приходит логический оператор "если". Так же существуют и другие команды, представляющие собой условие. Пожалуй, самым простым применением условия является назначение двух чередующихся действий на одну и ту же горячую клавишу. В этом примере введена переменная, которая принимает противоположное значение при каждом новом вызове ГК.
RSHELL_LEARN_TEXT_LOGIC_OPERATIONS_2=Логические операции (2/3)
RSHELL_LEARN_TEXT_PAGE_35=пер а = 0\nгк Alt,1:\nесли '`а`' == '0' то вывод переменная а равна нулю``;пер а = 1``;конец\nесли '`a`' == '1' то вывод переменная а равна 1``; пер а = 0``;конец\nконец
RSHELL_LEARN_TEXT_LOGIC_OPERATIONS_3=Логические операции (3/3)
RSHELL_LEARN_TEXT_PAGE_36=Еще одним примером может служить определение времени суток:\nгк Alt,1:\nесли '`.время.час`' < '6' то вывод Сейчас ночь``;конец\nесли '`.время.час`' < '10' то вывод Сейчас утро``;конец\nесли '`.время.час`' < '17' то вывод Сейчас день``;конец\nвывод Сейчас вечер;конец
RSHELL_LEARN_TEXT_RUN_PROGRAMS_AND_LINKS_1=Запуск программ, открытие ссылок (1/2)
RSHELL_LEARN_TEXT_PAGE_37=Для запуска EXE приложений, открытия окон проводника или браузера есть множество способов.\n1. Используется вызов командной строки из Renux:\n// Запуск программы\nкмд start notepad.exe\n// Открытие ссылки.\nкмд http://vk.com/strdev
RSHELL_LEARN_TEXT_RUN_PROGRAMS_AND_LINKS_2=Запуск программ, открытие ссылок (2/2)
RSHELL_LEARN_TEXT_PAGE_38=2. Используется имя файла и параметры как в командной строке. В этом случае RS ожидает закрытие процесса.\n// Запуск программы\nnotepad.exe\n// Открытие ссылки\nhttp://vk.com/strdev
RSHELL_LEARN_TEXT_NOTES_ABOUT_COMMANDS_AND_FUNCS_1=Примечания про команды и функции (1/2)
RSHELL_LEARN_TEXT_PAGE_39=В Renux Shell есть две основных структуры: команды и функции. Обе предназначены для выполнения какого-либо действия, но отличаются способом записи. В данной программе функция используется как метка, но для ее вызова не используется команда "перейти", а нужно просто указать ее имя на строке. Стоит учесть, что функция не исполняется, пока ее не вызвать в коде. Пример:
RSHELL_LEARN_TEXT_NOTES_ABOUT_COMMANDS_AND_FUNCS_2=Примечания про команды и функции (2/2)
RSHELL_LEARN_TEXT_PAGE_40=// объявляем функцию\nфункция плюс_один:\nпер а += 1\nконец\n// бесконечный цикл\nметка цикл:\nплюс_один\nвывод %а%\nперейти цикл
RSHELL_LEARN_TEXT_CONCLUSION=Заключение
RSHELL_LEARN_TEXT_PAGE_41=В этом разделе приведены самые базовые возможности программы. Полный список функций можно найти на главной странице справочника (команда "СПРАВКА"). Рекомендуем последовательно пройти по описанию всех команд для примерного понимания их назначения перед тем, как начинать писать свой первый скрипт :)\nПеред тем, как приступить к написанию кода, необходимо составить алгоритм. Распишите по шагам, что должна делать ваша программа. Так будет гораздо проще искать команды, необходимые для выполнения каждого из шагов.
RSHELL_LEARN_TEXT_ERROR_TEXT1=Сначала установите Renux Shell через команду "КОНСОЛЬ УСТАНОВИТЬ". Если нет прав, то запустите программу от имени администратора и попробуйте еще раз.
RSHELL_LEARN_TEXT_ERROR_TEXT2=Не удалось выполнить команду.

// Документация встроенных переменных
RSHELL_VARINFO_TIME_DD=Применение: %.время.день%\nОписание: Текущий день месяца (2 цифры) от 01 до 31.
RSHELL_VARINFO_TIME_MONTH=Применение: %.время.месяц%\nОписание: Текущий месяц (2 цифры) от 01 до 12.
RSHELL_VARINFO_TIME_YEAR=Применение: %.время.год%\nОписание: Текущий год (4 цифры). Например: 2004.
RSHELL_VARINFO_TIME_HOUR=Применение: %.время.час%\nОписание: Текущий час (2 цифры) от 00 до 23. Например: 17 - это 5 часов вечера.
RSHELL_VARINFO_TIME_MIN=Применение: %.время.минута%\nОписание: Текущая минута (2 цифры) от 00 до 59.
RSHELL_VARINFO_TIME_SEC=Применение: %.время.секунда%\nОписание: Текущая секунда (2 цифры) от 00 до 59.
RSHELL_VARINFO_TIME_TICKCOUNT=Применение: %.время.счетчик%\nОписание: Количество миллисекунд, прошедшее со времени перезагрузки компьютера. Сохранив значение .время.счетчик в переменной, можно позднее измерить общее время работы. Для этого необходимо вычесть значение этой переменной из последнего значения .время.счетчик. Например:\n\n  пер время = %.время.счетчик%\n  ждать.время 1000\n  пер прошло_времени = %.время.счетчик%\n  пер прошло_времени -= %время%\n  вывод прошло %.прошло_времени% миллисекунд.
RSHELL_VARINFO_TIME_MMM=Применение: %.время.месяцк%\nОписание: Аббревиатура текущего месяца на языке пользователя. Например: Июл.
RSHELL_VARINFO_TIME_MMMM=Применение: %.время.месяцс%\nОписание: Полное название текущего месяца на языке пользователя. Например: Июль.
RSHELL_VARINFO_TIME_DDD=Применение: %.время.неделяк%\nОписание: Аббревиатура из трех букв текущего дня недели на языке пользователя. Например: Вск.
RSHELL_VARINFO_TIME_DDDD=Применение: %.время.неделяс%\nОписание: Полное название текущего дня недели на языке пользователя. Например: Воскресенье.
RSHELL_VARINFO_CONSOLE_VERSION=Применение: %.консоль.версия%\nОписание: Переменная содержит номер той версии Renux Shell, которая исполняет команды (например: 2.6). 
RSHELL_VARINFO_CONSOLE_ADMIN=Применение: %.консоль.админ%\nОписание: Если у текущего пользователя есть права администратора, переменная содержит значение 1. Иначе - 0.
RSHELL_VARINFO_CONSOLE_RESULT=Применение: %.консоль.результат%\n\nОписание: Это встроенная переменная, призванная отображать успешность или неуспешность выполнения каких-либо команд (однако, не все команды поддерживают работу с .консоль.результат). Значение .консоль.результат, равное единице, обычно свидетельствует об удачном завершении процесса. В .консоль.результат помещается ответ внутренней функции Renux, которая отвечает за выполнение предыдущей указанной Вами команды.\n\n Примечания:\n  Учитывая то, что некоторые команды выдают значение .консоль.результат большее, чем 1, наилучшим способом будет: проверка имеет ли переменная .консоль.результат значение, отличное от единицы.\n  Если Вы ограничили права на выполнение некоторых команд в Renux Shell, то при попытке выполнить запрещенную команду будет выводиться сообщение о том, что у пользователя недостаточно прав, также .КОНСОЛЬ.РЕЗУЛЬТАТ изменит свое значение на "-100" (минус сто).
RSHELL_VARINFO_CONSOLE_FOLDER=Применение: %.консоль.папка%\nОписание: Выводит путь к папке, которую выделил Renux Shell для хранения конфига и установки.
RSHELL_VARINFO_CONSOLE_WORKDIR=Применение: %.консоль.рпапка%\nОписание: Текущий рабочий каталог консоли, в котором файлы доступны по умолчанию. Конечный обратный слеш нужен только в случае, если это корневой каталог. Два примера: C:\ и C:\Мои документы. Чтобы изменить рабочий каталог, используйте команду "СД".
RSHELL_VARINFO_CONSOLE_PATH_DIR=Применение: %.консоль.путь.папка%\nОписание: Полный путь к каталогу, где находится консоль.
RSHELL_VARINFO_CONSOLE_SCRIPT=Применение: %.консоль.скрипт%\nОписание: Полный путь к исполняемому пакетному файлу.
RSHELL_VARINFO_CONSOLE_PATH=Применение: %.консоль.путь%\nОписание: Выводит путь к исполняемому файлу Renux Shell (путь к самому себе).
RSHELL_VARINFO_CONSOLE_NAME=Применение: %.консоль.имя%\nОписание: Выводит имя исполняемого файла Renux Shell (свое имя файла с расширением).
RSHELL_VARINFO_CONSOLE_ENV=Синтаксис: %.окр.<имя переменной окружения>%\nОписание: Выводит содержание определенной переменной окружения.
RSHELL_VARINFO_SYSTEM_APPDATA=Синтаксис: %.система.аппдата%\nОписание: Полный путь и имя папки, содержащей данные приложения текущего пользователя.
RSHELL_VARINFO_SYSTEM_CAPPDATA=Синтаксис: %.система.оаппдата%\nОписание: Полный путь и имя папки, содержащей данные для всех пользователей приложения.
RSHELL_VARINFO_SYSTEM_DESKTOP=Синтаксис: %.система.рстол%\nОписание: Полный путь и имя папки, содержащей файлы рабочего стола текущего пользователя.
RSHELL_VARINFO_SYSTEM_CDESKTOP=Синтаксис: %.система.орстол%\nОписание: Полный путь и имя папки, содержащей файлы рабочего стола всех пользователей.
RSHELL_VARINFO_SYSTEM_64BITOS=Синтаксис: %.система.64бит%\nОписание: Содержит 1 (истина), если ОС 64-разрядная, или 0 (ложь), если она 32-разрядная.
RSHELL_VARINFO_SYSTEM_DOCUMENTS=Синтаксис: %.система.документы%\nОписание: Полный путь и имя папки "Мои документы" текущего пользователя.
RSHELL_VARINFO_SYSTEM_PROGFILES=Синтаксис: %.система.прогфайлы%\nОписание: Каталог Program Files (например, C:\Program Files или C:\Program Files (x86)).
RSHELL_VARINFO_SYSTEM_PROGRAMS=Синтаксис: %.система.менюпуск%\nОписание: Полный путь и имя папки "Программы" в меню "Пуск" текущего пользователя.
RSHELL_VARINFO_SYSTEM_CPROGRAMS=Синтаксис: %.система.оменюпуск%\nОписание: Полный путь и имя папки "Программы" в меню "Пуск" для всех пользователей.
RSHELL_VARINFO_SYSTEM_STARTMENU=Синтаксис: %.система.стартменю%\nОписание: Полный путь и имя папки меню "Пуск" текущего пользователя.
RSHELL_VARINFO_SYSTEM_CSTARTMENU=Синтаксис: %.система.остартменю%\nОписание: Полный путь и имя папки меню «Пуск» для всех пользователей.
RSHELL_VARINFO_SYSTEM_STARTUP=Синтаксис: %.система.автозапуск%\nОписание: Полный путь и имя папки «Автозагрузка» в меню «Пуск» текущего пользователя.
RSHELL_VARINFO_SYSTEM_CSTARTUP=Синтаксис: %.система.оавтозапуск%\nОписание: Полный путь и имя папки «Автозагрузка» в меню «Пуск» для всех пользователей.
RSHELL_VARINFO_SYSTEM_OSTYPE=Применение: %.система.тип%\nОписание: Тип запущенной операционной системы. Или WIN32_WINDOWS (т.е. Win95/98/ME), или WIN32_NT (т.е. WinNT, Win2k, WinXP и, возможно, более поздние).
RSHELL_VARINFO_SYSTEM_VERSION=Применение: %.система.версия%\nОписание: Одна из следующих строк: WIN_2003, WIN_XP, WIN_2000, WIN_NT4, WIN_95, WIN_98, WIN_ME.
RSHELL_VARINFO_SYSTEM_USERNAME=Применение: %.система.пользователь%\nОписание: Имя текущего пользователя, под которым он вошел в систему.
RSHELL_VARINFO_SYSTEM_COMPUTER=Применение: %.система.компьютер%\nОписание: Сетевое имя компьютера.
RSHELL_VARINFO_SYSTEM_CLIPBOARD=Применение: %.система.клипборд%\nОписание: Содержимое буфера обмена операционной системы, доступное для чтения и записи.
RSHELL_VARINFO_SCREEN_WIDTH=Применение: %.экран.ширина%\nОписание: Ширина основного монитора в пикселях (например, 1024).
RSHELL_VARINFO_SCREEN_HEIGHT=Применение: %.экран.высота%\nОписание: Высота основного монитора в пикселях (например, 768).x
RSHELL_VARINFO_CONSOLE_SPACE=Применение: %.консоль.пробел%\nОписание: Переменная равная пробелу.

// Документация "основного"
RSHELL_MAININFO_HOTKEYS1=Предупреждение: работает только в режиме исполнения пакетного файла.\n\nГорячие клавиши иногда называют "быстрыми клавишами" из-за их способности без труда активировать операции (например, запускать программу или клавиатурную макрокоманду). В примере, приведенном ниже, горячая клавиша Alt+N настроена на то, чтобы запускать Блокнот (Notepad):\n\n  гк Alt,N:\n  кмд start notepad\n  конец\n\nВ последней строке команда "конец" служит для того, чтобы завершить работу горячей клавиши. Вы можете использовать много (до бесконечности) клавиш для активации макрокоманд. Их перечисляют через запятую. В примере ниже при нажатии Ctrl+Alt+T будет напечатано сообщение "Hello World":\n\n  гк Ctrl,Alt,T:\n  // На следующей строке эмуляция нажатия клавиш относится к активному окну\n  напечатать Hello World\n  конец
RSHELL_MAININFO_HOTKEYS2=Метки горячих клавиш можно использовать как обычные метки: вы можете использовать команду "перейти" и задать несколько меток горячих клавиш, чтобы выполнить одну и ту же процедуру. Например:\n\n  гк Alt,1:\n  гк Alt,2:\n  вывод Вы нажали Alt+1 или Alt+2.\n  конец\n\nВы можете привязать ко клавише любые доступные команды Renux Shell. Например, при нажатии на правый Ctrl активное окно откроется во весь экран:\n  гк RCtrl:\n  окно.развернуть A\n  конец
RSHELL_MAININFO_CREATING_MACROCMDS_KEYBOARD_MOUSE=Создание макрокоманды клавиатуры и мыши
RSHELL_MAININFO_MACROCOMMANDS=Макрокоманда - это последовательность скриптовых действий, которая "воспроизводится" по требованию. Самым общим видом деятельности макрокоманды является эмуляция нажатий клавиш и кликов мышью в одно или несколько окон. Такие окна реагируют на каждое нажатие клавиши и клик мыши так, как будто это действие выполнено вручную, что позволяет автоматизировать повторяющиеся задачи с высокой скоростью и надежностью.\nДля того, чтобы сейчас же начать создание своих собственных макрокоманд и горячих клавиш, обратитесь к разделу в справке "Начало работы > Краткое обучение".
RSHELL_MAININFO_LIST_OF_KEYS_AND_MOUSE_BUTTON=Список клавиш и кнопок мыши
RSHELL_MAININFO_LOKAMB_TEXT1=Мышь:\n> LButton - левая кнопка мыши\n> RButton - правая кнопка мыши\n> MButton - средняя кнопка мыши (или колесо)\n> WheelDown - поворот колеса мыши "вниз"\n> WheelUp - поворот колеса мыши "вверх"\n> XButton1 - четвертая кнопка мыши, боковая\n> XButton2 - пятая кнопка мыши, боковая\n\nКлавиатура:\n(( Примечание: названия буквенных и цифровых клавиш точно такие же, как и сами символы этих клавиш. То есть, клавиша "b" записывается как b, а клавиша "5" как 5. ))\n> Space - пробел\n> Tab\n> Enter (или Return)\n> Escape (или Esc)\n> Backspace (или BS)\n> Delete (или Del)\n> Insert (или Ins)\n> Home\n> End\n> PgUp\n> PgDn\n> Up\n> Down\n> Left\n> Right\n> ScrollLock\n> CapsLock\n> NumLock\n> NumpadDiv - слэш "/"\n> NumpadMult - звездочка "*"\n> NumpadAdd - плюс "+"\n> NumpadSub - минус "-"\n> NumpadEnter - клавиша "Numpad-Enter"
RSHELL_MAININFO_LOKAMB_TEXT2=Следующие названия клавиш используются, когда Numlock выключен:\n> NumpadDel\n> NumpadIns\n> NumpadClear - та же кнопка, что и Numpad5 на клавиатуре\n> NumpadUp\n> NumpadDown\n> NumpadLeft\n> NumpadRight\n> NumpadHome\n> NumpadEnd\n> NumpadPgUp\n> NumpadPgDn\n\nЭти названия клавиш используются при включенном Numlock'e:\n> Numpad0\n> Numpad1\n> Numpad2\n> Numpad3\n> Numpad4\n> Numpad5\n> Numpad6\n> Numpad7\n> Numpad8\n> Numpad9\n> NumpadDot - "Numpad-точка"
RSHELL_MAININFO_LOKAMB_TEXT3=С F1 по F24 - двенадцать или более функциональных клавиш, на большинстве клавиатур представлены в самом верхнем ряду.\n\n> AppsKey - клавиша, вызывающая контекстное меню файла/программы, как при правом клике мышкой.\n> LWin - левая клавиша "Windows"\n> RWin - правая клавиша "Windows"\n> Control (или Ctrl)\n> Alt\n> Shift\n> LControl (или LCtrl) - левый "Сontrol"\n> RControl (или RCtrl) - правый "Сontrol"\n> LShift\n> RShift\n> LAlt - левый "Alt"\n> RAlt - правый "Alt". Примечание: если на вашей клавиатуре вместо клавиши RAlt сделана клавиша AltGr, вы можете использовать следующую запись данной клавиши: <^>! Также заметим, что клавишу AltGr можно записать как сочетание клавиш "LControl & RAlt::".\n> PrintScreen\n> CtrlBreak\n> Pause\n> Break\n> Help - довольно редкая клавиша, присутствует далеко не на всех клавиатурах. И работает совсем не как F1.\n> Sleep - предупреждаем, что клавиша "Sleep" на некоторых клавиатурах не работает под этой записью.
RSHELL_MAININFO_LOKAMB_TEXT4=Клавиши расширенных функций Мультимедийных и Интернет-клавиатур:\n> Browser_Back\n> Browser_Forward\n> Browser_Refresh\n> Browser_Stop\n> Browser_Search\n> Browser_Favorites\n> Browser_Home\n> Volume_Mute\n> Volume_Down\n> Volume_Up\n> Media_Next\n> Media_Prev\n> Media_Stop\n> Media_Play_Pause\n> Launch_Mail\n> Launch_Media\n> Launch_App1\n> Launch_App2\n\nЗапись вида SCnnn, где nnn - это сканкод клавиши, позволяет нам работать с остальными клавишами, не упоминавшимися выше.\nВозможна запись VKnn, где nn является шестнадцатиричным виртуальным кодом клавиши.
RSHELL_MAININFO_SCRIPT_TEXT1=Каждый пакетный файл представляет собой простой текстовый файл, содержащий команды, которые затем будет исполнять программа (rshell.exe). Пакетный файл также может содержать горячие клавиши, и даже полностью состоять из них. Однако, в отсутствие горячих клавиш, после запуска скрипта его команды исполняются последовательно друг за другом сверху донизу. При запуске пакетные файлы оптимизируются, но не проверяются. При создании нового пакетного файла (создание текстового файла), нужно установить кодировку ANSI, иначе пакетный файл может не запуститься на вашем/другом компьютере.\n\nСекция автовыполнения:\nПрограмма, строка за строкой, загружает скрипт в память (каждая строка может содержать до 16 383 символов). После загрузки программа исполняет скрипт до тех пор, пока не дойдет до команд конец, выход, метки горячей клавиши, или конца скрипта (в зависимости от того, что стоит первым). Эта верхняя часть скрипта называется секцией авто-выполнения.\nНе завершающий работу автоматически не содержащий горячие клавиши скрипт заканчивает свою работу после окончания секции авто-выполнения. Иначе, он будет работать в состоянии ожидания, реагируя на такие события, как запуск горячих клавиш и т.п.\n\nEscape-последовательности:\nВ Renux Shell escape-символом по умолчанию является знак акцента (`), находящийся в верхнем левом углу большинства английских клавиатур. Использование этого символа вместо обратного слеша устраняет необходимость в двойном обратном слеше в пути и имени файла.\nТакже с помощью escape-последовательности задаются специальные символы. Чаще всего это `t (табуляция), `n (перевод строки) и `r (возврат каретки).
RSHELL_MAININFO_SCRIPT_TEXT2=Комментарии:\nВ скрипте можно добавлять комментарии в начале строки после двух слэшей. Например:\n\n  // Вся эта строка является комментарием.\n\nМобильность rshell.exe:\nВсе, что необходимо для запуска любого .rs-скрипта - это файл rshell.exe.
RSHELL_MAININFO_VARIABLES_TEXT1=Введение в переменные:\nПеременными являются участки памяти, где хранятся значения. Значение (или строка, как его иногда называют) может представлять собой любую последовательность символов или цифр. Хотя между текстом и числами не делается никаких различий (и то и другое хранится в виде строк), в некоторых контекстах трактовка строки, полностью состоящей из чисел, отличается от трактовки других строк. Например, если в выражении InputString > BookmarkString обе переменные будут иметь числовые значения, они будут сравниваться как числа. Иначе, сравнение будет производиться в соответствии с алфавитным порядком.\nВ примере, приведенном ниже, показано, как присвоить переменной значение:\n\n  пер моя_переменная = 123абв\n\nЧтобы позднее извлечь содержимое этой переменной, сошлитесь на нее, поместив ее имя между знаками процента:\n\n  вывод Значение переменной моя_переменная - %моя_переменная%\n\nОднако параметры некоторых команд явно определены как входные или выходные переменные.\nВ этих случаях нет необходимости помещать переменную между знаками процента.
RSHELL_MAININFO_VARIABLES_TEXT2=Замечания по поводу возможностей переменных и использования памяти:\n> Каждая переменная может содержать до 256 MB текста.\n> Когда переменной присваивается строка длиннее, чем ее текущее содержимое, дополнительная системная память выделяется автоматически.\n> Память, занятую большой переменной, можно освободить, присвоив переменной пустое значение, например: пер моя_переменная =\n> Команды, функции и выражения, принимающие числовые входные данные, обычно поддерживают степень точности 15 цифр после запятой (для значений с плавающей запятой). Для целых чисел поддерживаются 64-разрядные значения со знаком в пределах от -9223372036854775808 (-0x8000000000000000) до 9223372036854775807 (0x7FFFFFFFFFFFFFFF). Любая целочисленная константа, не входящая в этот диапазон, будет установлена на ближайшее целое число, принадлежащее диапазону. В отличие от этого, при арифметических операциях с целыми числами, при переполнении число циклически обращается (например, 0x7FFFFFFFFFFFFFFF + 1 = -0x8000000000000000).
RSHELL_MAININFO_VARIABLES_TEXT3=Встроенные переменные:\nТакже в скриптах можно использовать встроенные переменные. Большинство из них является "зарезервированными" (reserved), что означает, что скрипт не может непосредственно изменять их содержимое. Подробнее о них можете увидеть в разделе справки "Встроенные переменные".

// Документация "аддоны"
RSHELL_ADDONSINFO_QUICKSTART_TEXT=Аддоны позволяют создавать свои команды со своим алгоритмом выполнения на языке Renux Shell.\nЕсли имеются установленные аддоны, то Renux Shell загружает их в память.\n\nАддоны состоят из двух файлов.\n*.rs - пакетный файл (алгоритм аддона).\n*.rsa - файл, который регистрирует команду аддона.
RSHELL_ADDONSINFO_CREATING_TEXT1=Файл, который отвечает за регистрацию аддонов, имеет расширение *.rsa (например, аддон.rsa).\nВ этом файле указывается информация о синтаксисе команд и др.\n\nСтоит учесть, что для аддонов используется стандартный парсер аргументов RS, так что каждый аргумент записывается в " ' " (одинарные кавычки). Исключение: когда используется один аргумент, кавычки не требуются\n\nПример записи файла:\n[addon]\ncommand=проверка\ndescription=Тестирование аддона в Renux Shell\nsyntax=проверка '<текст для вывода 1>' '<текст для вывода 2>'\nexample=проверка 'раз два три' 'четыре пять шесть'\nparam_count=2\noutput_array=текст\nbatch_file=алгоритм_проверки\n\nСтрока "[addon]" должна быть указана!\nГде "command", указывается название команды, которая будет активировать аддон.\nГде "description", указывается описание команды, если указаны не все аргументы.\nГде "syntax", указывается формат команды в виде текста, если указаны не все аргументы.\nГде "example", указывается пример команды в виде текста, если указаны не все аргументы.\nГде "param_count", указывается количество аргументов, которая должна принимать команда.\nГде "output_array", указывается имя массива, в который будут записаны аргументы, которые указал пользователь.\nГде "batch_name", указывается файл без расширения *.rs, который будет выполняться, когда все аргументы будут указаны.
RSHELL_ADDONSINFO_CREATING_TEXT2=После того, как пользователь укажет все принимаемые аргументы для команды, все аргументы записываются в массив, указанный в параметре "массив_для_вывода" в *.rsa файле.\n\nПример, на котором выводятся значения двух аргументов, указанные пользователем:\n  вывод В первом аргументе было указано: %текст[1]%\n  вывод Во втором аргументе было указано: %текст[2]%\n\nПосле того, как исполнение пакетного файла будет завершено, Renux вернется в обычный режим.
RSHELL_ADDONSINFO_COMPILING_TEXT=Когда Вы создадите *.rs и *.rsa файлы, Вы сможете их объединить в один файл (расширение *.rsac) и установить через команду "АДДОН" в Renux Shell. Собрать же сможете также через команду "АДДОН".
RSHELL_ADDONSINFO_DELETE_TEXT=Если Вам нужно удалить установленный аддон, то используйте команду "АДДОН".

// Апдейтлисты
RSHELL_UPDINFO_2_0=- Самая первая версия программы.
RSHELL_UPDINFO_2_1=- Исправлена работа команды "окно.элемент.напечатать".\n- Исправлены мелкие ошибки в программном коде.\n- Новый аргумент командной строки "/log" (записывает в файл лог содержимое консоли).\n- Новая команда "ждать.нажатие" (Ожидает нажатие на клавишу(-и), указанную Вами).\n- Переработан алгоритм показа значений переменных.\n- Новая команда "СОБРАТЬ" ("Скомпилирует" пакетный файл Renux Shell в .exe формат).\n- Шифрование алгоритма пакетных файлов двумя ключами шифрования (доступно в команде "СОБРАТЬ").\n- При нажатии Shift и Enter одновременно, появится еще одна строка для ввода. Все указанные команды (с новой строки) будут последовательно обработаны (альтернатива "&" в командной строке Windows).\n- Новая команда "ПОСТ" (отправляет POST-запрос на указанный Вами сервер).\n- Теперь Renux не открывает новую сессию при просьбе пользователя открыть пакетный файл Renux Shell.\n- Новое поведение программы при фатальной ошибке.\n- Теперь в именах переменных можно использовать только английские/русские буквы, цифры, символ "_".
RSHELL_UPDINFO_2_2=- Оптимизирован алгоритм отображения значений переменных.\n- Новая встроенная переменная ".консоль.результат", которая будет содержать ответ предыдущей внутренней функции Renux, которая отвечает за выполнение указанной Вами команды.\n- Новая команда "СТРОКА.РАЗДЕЛИТЬ" (разделяет строку на подстроки, в зависимости от заданного разделителя).\n- Новая команда "СТРОКА.ЗАМЕНИТЬ" (заменяет вхождения строки поиска на строку замены).\n- Новая команда "МАССИВ.ОБЪЕДИНИТЬ" (сливает один массив и записывает в указанную Вами переменную).\n- Изменен синтаксис команды "ВКАПИ".\n- В команде "ФАЙЛ.ПРОЧИТАТЬ", теперь вместо записи текста файла в переменую, записывается в массив по строке.\n- Теперь в именах меток можно использовать только английские/русские буквы, цифры, символ "_".\n- Новая команда "ГК" (активирует по нажатию клавиш(-и) участок сценария).\n- Новая команда "ИНИ.УДАЛИТЬ" (удаляет параметр из INI-файла стандартного формата).\n- Новая команда "ИНИ.ПРОЧИТАТЬ" (читает значение параметра из INI-файла стандартного формата).\n- Новая команда "ИНИ.ЗАПИСАТЬ" (пишет параметр в INI-файл стандартного формата).\n- Новая команда "АДМИН" (запросит права администратора и перезапустит сценарий (если он запущен)).\n- Теперь Вы можете "складывать" строки через команду "ПЕР" (нужно чтобы значение переменной не было числом) (сделает слияние строк).\n- Теперь Вы можете "уменьшать" строки через команду "ПЕР" (нужно чтобы значение переменной не было числом) (заменяет вхождения из второго параметра на пустоту).\n- Теперь Вы можете "умножать" строки через команду "ПЕР" (нужно чтобы значение переменной не было числом) (сделает слияние строк столько раз, сколько Вам будет нужно) [ВО ВТОРОМ ПАРАМЕТРЕ ДОЛЖНО БЫТЬ ЧИСЛО].\n- Теперь Вы можете "разделить" строки через команду "ПЕР" (нужно чтобы значение переменной не было числом) (запишет в значение переменной количество найденных входений в значении переменной).\n- Новая команда "СЕТЬ.ВВОД" (передает сообщения по локальной сети).\n- Новая команда "СЕТЬ.ВЫВОД" (получает сообщения по локальной сети).
RSHELL_UPDINFO_2_3=- Новая команда "ПШ" (выполнит команду в PowerShell).\n- Новая команда "ГОЛОС.СКАЗАТЬ" (преобразует текст в речь (Text-To-Speech)).\n- Новая команда "ГОЛОС.ГРОМКОСТЬ" (установит параметр громкости для преобразования текста в речь (Text-To-Speech)).\n- Новая команда "ГОЛОС.СКОРОСТЬ" (установит параметр скорости речи для преобразования текста в речь (Text-To-Speech)).\n- Мелкие правки в справке.\n- Новая команда "ФУНКЦИЯ" (метка, к которой можно обратиться из другого места сценария).\n- Новая команда "СЕТЬ.СКАНИРОВАТЬ" (отображает текущие ARP записи, опрашивая текущие данные).\n- Новая операция в команде "ПЕР" под именем "ЗАМЕНИТЬ" (работает также, как и команда СТРОКА.ЗАМЕНИТЬ).\n- Новая операция в команде "ПЕР" под именем "РАЗДЕЛИТЬ" (работает также, как и команда СТРОКА.РАЗДЕЛИТЬ).\n- Новая операция в команде "ПЕР" под именем "слева" (запишет в переменную указанное число символов строки слева).\n- Новая операция в команде "ПЕР" под именем "справа" (запишет в переменную указанное число символов строки справа).\n- Новая операция в команде "ПЕР" под именем "длина" (запишет в переменную количество символов строки).\n- Новая операция в команде "ПЕР" под именем "вверх" (преобразует строку в верхний регистр и запишет в переменную).\n- Новая операция в команде "ПЕР" под именем "вниз" (преобразует строку в нижний регистр и запишет в переменную).\n- Переход на 64-разрядное приложение.\n- Новая команда "СЕТЬ.СООБЩЕНИЕ" (отправит сообщение по локальной сети и дождется его чтения).
RSHELL_UPDINFO_2_4=- Добавлено предупреждение о компонентах, работающих только в Windows 10 (если версия ядра ОС не совпадает с Windows 10).\n- Исправлены программные ошибки в команде "ПЕР".\n- Теперь режим отладки вызывает GUI, в котором отображаются все события.\n- Новая команда "ФАЙЛ.КОПИРОВАТЬ" (копирует содержимое файла в другой файл).\n- Новая команда "РЕСТАРТ" (перезапустит Renux Shell).\n- Новая команда "ФАЙЛ.КОПИРОВАТЬ.ПАПКА" (копирует папку вместе с содержимым в другое место).\n- Новая команда "ФАЙЛ.СОЗДАТЬ.ПАПКА" (создаст папку по указанному Вами пути).\n- Новая команда "ФАЙЛ.СОЗДАТЬ.ЯРЛЫК" (создаст ярлык, который будет активировать указанный Вами файл).\n- Новая команда "АТРИБУТЫ.ПОЛУЧИТЬ" (читает атрибуты файла или папки).\n- Новая команда "АТРИБУТЫ.УСТАНОВИТЬ" (изменяет атрибуты файла или папки).\n- Новая команда "ФАЙЛ.ВРЕМЯ.УСТАНОВИТЬ" (изменяет отметку даты и времени файла или папки).\n- Новая команда "ФАЙЛ.ВРЕМЯ.ПОЛУЧИТЬ" (возвращает отметку даты и времени файла или папки).\n- Новая команда "ФАЙЛ.РАЗМЕР" (определяет размер файла в байтах).\n- Новая команда "ФАЙЛ.ПЕРЕМЕСТИТЬ.ПАПКА (перемещает/переименовывает папку вместе со всеми её подпапками и файлами).\n- Изменен синтаксис команды "ЖДАТЬ.НАЖАТИЕ" на более привычный для Renux Shell.\n- Новая команда "ФАЙЛ.ПОЛУЧИТЬ.ЯРЛЫК" (возвращает свойства ярлыка в виде массива).\n- Новая команда "ФАЙЛ.ПРОЧИТАТЬ.СТРОКА" (читает определённую строку в файле и помещает текст в переменную).\n- Новая команда "ФАЙЛ.УДАЛИТЬ.ПАПКА" (удаляет папку по указанному Вами пути).\n- Новая команда "ДИСК.ПРИВОД" (выдвигает/втягивает лоток CD- или DVD-привода).\n- Новая команда "ДИСК.ПОЛУЧИТЬ" (предоставляет разного рода информацию о дисках компьютера).\n- Новая команда "ДИСК.ПОЛУЧИТЬ.СПАМЯТЬ (определяет объём свободного места на диске, в мегабайтах).\n- Изменен синтаксис команды "СЕТЬ.СООБЩЕНИЕ": второй аргумент обязателен.\n- Новая команда "КОНСОЛЬ" (установщик Renux Shell).\n- Новый параметр запуска "install" (установит Renux Shell в систему).\n- Новый параметр запуска "deinstall" (удалит Renux Shell с Вашего ПК).\n- Новая переменная ".система.компьютер" (отобразит системное имя ПК).\n- Новая переменная ".система.пользователь" (отобразит системное имя ПК).\n- Новая команда "ПРОГ" (взаимодействует с программами от Streleckiy Development).
RSHELL_UPDINFO_2_5=- Фикс установщика при использовании команды "ПРОГ".\n- Доработана система автоматического обновления.\n- Команда "ФАЙЛ.ПРОЧИТАТЬ" вновь записывает содержание файла в переменную.\n- Теперь команды для выполнения разделяются не новой строкой, а знаком ";" (но ничего не мешает использовать новую строку).\n- Команды "СЕТЬ.ВВОД" временно вырезаны.\n- Команда "СЕТЬ.ВЫВОД" временно вырезана.\n- Добавлены последовательности символов (подр. в команде "СПРАВКА").\n- Переработан алгоритм распознавания команд.\n- Изменен синтаксис команды "МЫШЬ.ПЕРЕДВИНУТЬ".\n- Изменен синтаксис команды "ФАЙЛ.УДАЛИТЬ".\n- Переработан алгоритм условий, но синтаксис не изменен (команда "ЕСЛИ").\n- Переработан алгоритм работы с переменными, но синтаксис не изменен (команда "ПЕР").\n- Изменен синтаксис команды "ОКНО.ЭЛЕМЕНТ.ПЕРЕДВИНУТЬ".\n- Изменен формат справки для быстрой навигации по ней.\n- Команда "СОБРАТЬ" временно вырезана.\n- Новая команда "ВЫЙТИ" (завершит работу/выйдет из системы и т.п).\n- Новая команда "ДИР" (отобразит содержимое текущей директории).\n- Новая команда "СД" (смена текущей директории).\n- Новая команда "СД." (аналогично СД.., СД...) (переход в родительский каталог (на один уровень вверх)).\n- Новая команда "ПРОЦЕСС" (выполняет операции над процессом).
RSHELL_UPDINFO_2_6=- Изменены флаги команды "выйти".\n- Новая переменная ".система.буферобмена" (выводит/изменяет буфер обмена). \n- Новая справка в виде отдельных окон с графическим пользовательским интерфейсом (замена команде "СПРАВКА").\n- Фикс обновления Renux Shell.\n- Мелкие фиксы команд.\n- Новая команда "ПРОЗРАЧНОСТЬ" (изменяет прозрачность окна командной строки Renux Shell).\n- Фикс экранизации символов.\n- Новый флаг для команды "ВЫЙТИ" (отменить запланированное завершение работы).\n- Новая команда "ГРОМКОСТЬ" (изменяет настройки звукового устройства (микшера)).\n- Новая команда "СООБЩЕНИЕ" (отображает на экране диалоговое окно с кнопками (например: да/нет))\n- Новая команда "УВЕДОМЛЕНИЕ" (создает всплывающее окно с сообщением рядом со значком в трее. В Windows 10 вместо этого может отображаться всплывающее уведомление).\n- Новая команда "МОНИТОР" (выключает/включает монитор).\n- Новая команда "АСИНХ" (выполнит команду асинхронно).\n- Новая команда "ГУДОК" (издаёт звук через динамик системного блока).\n- Новая команда "ЗВУКИНФО" (считывает текущие настройки звукового устройства (микшера)).\n- Теперь список обновлений доступен в справке: в разделе "Список обновлений".\n- Новая команда "ПРОИГРАТЬ" (проигрывает аудио- и видеофайлы, или файлы другого поддерживаемого формата).\n- Новая команда "РЕЕСТР.ЗАПИСАТЬ" (записывает параметр в реестр).\n- Новая команда "РЕЕСТР.ПРОЧИТАТЬ" (читает параметр из реестра).\n- Новая команда "РЕЕСТР.УДАЛИТЬ" (удаляет раздел или параметр реестра).\n- Новая встроенная переменная ".ЭКРАН.ШИРИНА" (ширина основного монитора в пикселях).\n- Новая встроенная переменная ".ЭКРАН.ВЫСОТА" (высота основного монитора в пикселях).\n- Новая команда "ЯРКОСТЬ" (изменяет яркость экрана).\n- Теперь после исполнения пакетного файла программа не закроется (искл. через "Открыть с помощью").\n- Новая команда "АДДОН" (устанавливает/удаляет/собирает аддоны).\n- Новые действия в команде "ЕСЛИ" (если (файл/переменая) (существует/не существует)).
RSHELL_UPDINFO_2_7=- Фиксы и улучшения.\n- Новая команда "СОЗДАТЬДАННЫЕФОРМЫ" (создает из файла объект, который можно отправить на сервер, командой "ЗАПРОС").\n- Новая команда "РАНД" (генерирует случайное число и записывает его в переменную).\n- Новая команда "ЗАПРОС" (вызывает объект "WinHttpRequest.5.1", через который Вы сможете отправить "кастомный" запрос).\n- Вырезана функция расшифровки зашифрованных сценариев Renux Shell.\n- Исправлены баги при выполнении пакетных файлов.\n- Теперь Renux Shell вновь запустится на 32-разрядной системе.\n- Вырезана команда "СЕТЬ.СООБЩЕНИЕ".
RSHELL_UPDINFO_2_8=- Новый параметр команды "КОНСОЛЬ" под именем "ОБНОВИТЬ".\n- Новая команда "СОБРАТЬ" (конвертирует пакетный файл Renux Shell в исполняемый файл (*.exe)).
RSHELL_UPDINFO_2_9=- Новая переменная %.консоль.имя% (выводит имя исполняемого файла Renux Shell (свое имя файла с расширением)).\n- Новая переменная %.консоль.путь% (выводит путь к исполняемому файлу Renux Shell (путь к самому себе)).\n- Новая переменная %.консоль.папка% (выводит путь к папке, которую выделил Renux Shell для хранения конфига и установки).\n- Изменен порядок пунктов в списке обновлений в справке (теперь вверху самые актуальные версии).\n- Теперь в пунктах списка обновлений указывается дата, когда была выпущена версия.\n- Новые переменные с префиксом "%.окр" (например, %.окр.comspec% выводит содержимое системной переменной ComSpec).\n- Новая команда "ОКРУЖЕНИЕ.ОБНОВИТЬ" (уведомляет операционную систему и все текущие приложения о том, что переменные среды изменились).\n- Новая команда "ОКРУЖЕНИЕ.ПОЛУЧИТЬ" (получает значение переменной окружения).\n- Новая команда "ОКРУЖЕНИЕ.УСТАНОВИТЬ" (задаёт значение переменной окружения).\n- Новая переменная '.консоль.рпапка' (текущий рабочий каталог консоли, в котором файлы доступны по умолчанию).\n- Новая переменная '.консоль.путь' (определяет полную спецификацию файла консоли, например: C:\My Documents\renux.exe).\n- Новая переменная '.консоль.путь.папка' (полный путь к каталогу, где находится консоль).\n- Новая переменная '.консоль.скрипт' (полный путь к исполняемому пакетному файлу).\n- Новая переменная '.система.аппдата' (полный путь и имя папки, содержащей данные приложения текущего пользователя).\n- Новая переменная '.система.оаппдата' (полный путь и имя папки, содержащей данные для всех пользователей приложения).\n- Новая переменная '.система.рстол' (полный путь и имя папки, содержащей файлы рабочего стола текущего пользователя).\n- Новая переменная '.система.орстол' (полный путь и имя папки, содержащей файлы рабочего стола всех пользователей).\n- Новая переменная '.система.64бит' (содержит 1 (истина), если ОС 64-разрядная, или 0 (ложь), если она 32-битная).\n- Новая переменная '.система.документы' (полный путь и имя папки "Мои документы" текущего пользователя).\n- Новая переменная '.система.прогфайлы' (каталог Program Files (например, C:\Program Files или C:\Program Files (x86))).\n- Новая переменная '.система.менюпуск' (полный путь и имя папки "Программы" в меню "Пуск" текущего пользователя).\n- Новая переменная '.система.оменюзапуск' (полный путь и имя папки "Программы" в меню "Пуск" для всех пользователей).\n- Новая переменная '.система.стартменю' (полный путь и имя папки меню "Пуск" текущего пользователя).\n- Новая переменная '.система.остартменю' (полный путь и имя папки меню «Пуск» для всех пользователей).\n- Новая переменная '.система.автозапуск' (полный путь и имя папки «Автозагрузка» в меню «Пуск» текущего пользователя).\n- Новая переменная '.система.оавтозапуск' (полный путь и имя папки «Автозагрузка» в меню «Пуск» для всех пользователей).
RSHELL_UPDINFO_2_9_1=- Оптимизирована система обновления переменных (программа работает быстрее).\n- Оптимизировано время инициализирования программы (программа запускается быстрее).\n- Теперь Renux Shell может открывать файлы. Вам нужно указать вместо команды путь к файлу и нужные параметры (как в cmd.exe).
RSHELL_UPDINFO_2_10=- Команда "джсон" больше не показывает ошибки. Ошибки указываются в окне отладки.\n- Теперь при обновлении/установке программы создается ярлык в меню Пуск (дополнительное удобство).\n- Теперь команды "СД.." и "СД..." работают по другому алгоритму, отличаюищийся от "СД." (подр. в справке по этим командам).\n- Теперь при указании директории можно использовать часть названия (команда "СД").\n- Новая команда "ФАЙЛ.ИСКАТЬ" (производит поиск по хранилищу с целью поиска файлов/папок по указанному шаблону).\n- Новая команда "ФАЙЛ.ПОЛУЧИТЬ" (записывает в массив свойства файла (обычно для .EXE, .DLL файлов)).\n- Теперь команда "ДИР" может искать файлы по шаблону.\n- Теперь команда "СД" может обрабатывать ярлыки и переключаться к их папкам (подр. в справке, см. синтаксис).
RSHELL_UPDINFO_2_11=- Теперь в заголовке окна указывается от чьего имени запущена программы.\n- Важные фиксы в команде "ЕСЛИ" (ранее была некорректная работа условия ">").\n- Новая команда "ПОКА" (выполняет команду несколько раз, пока указанное выражение не станет ложным).\n- Новая команда "ЦИКЛ" (выполняет команду несколько раз).\n- Новая команда "ДЛЯ" (один раз повторяет серию команд для каждой пары "ключ-значение" в объекте).\n- Дополнено "Краткое обучение".\n- Новые ограничения для названия массивов.
RSHELL_UPDINFO_2_12=- Мелкие фиксы и улучшения.\n- Немного изменен порядок разделов в справке.\n- Новая команда "ПРОГРАММА" или "??" (открывает информацию о программе, не путать со справкой).\n- Теперь команда "КОНЕЦ" завершает работу пакетного файла, если он не ожидает нажатие горячих клавиш.\n- Новая команда "ПАУЗА" (ожидает нажатие клавиши), альтернатива команды "КМД PAUSE".\n- Теперь программа запускается как консольно-интерфейсное приложение (Renux Shell подключается к консоли, из которой его вызывают).\n- Изменено поведение программы во время ошибки.\n- Новая команда "СПИСОК" (выводит список всех команд программы в консоль).\n- Программа больше не имеет заголовок окна по-умолчанию.
RSHELL_UPDINFO_2_13=- Новая команда "ВВОДК" (ждёт, пока пользователь напечатает строку).\n- Новая переменная ".КОНСОЛЬ.ПРОБЕЛ" (содержит пробел).\n- Теперь программа предупреждает о возможных ошибках, если его вызывают не через командную строку.\n- Программа меняет заголовок своей консоли, если она не вызвана из командных строк.\n- Новая команда "ПРОЦЕСС.ИСКАТЬ" (записывает в массив список процессов с их идентификаторами).\n- Поправки в синтаксисе RS: теперь программа распознает символ «"» аналогично символу «'». Другими словами, команду «мышь.передвинуть '100' '100' '50'» можно записать так - «мышь.передвинуть "100" "100" "50"». Можно использовать одинарные и двойные кавычки для обозначения границ в одной команде, например - «мышь.передвинуть "100' '100" '50"». Ошибок при этом не возникнет. \n- Новая команда "ЗВЫВОД" (изменяет режим вывода сообщений Renux).
RSHELL_UPDINFO_2_14=- Много изменений в команде "СПРАВКА". Подробнее в справке.\n- Теперь команда "СПИСОК" работает по другой технологии.\n- При нажатии в справке "О программе -> [Информация о программе]" теперь отображается кол-во команд.\n- Команда "АСИНХ" временно вырезана.\n- Теперь в справке указываются другие вариации команды (если имеется).\n- Новая команда "ВЫВОДБ" (выводит сообщение в консоль с без перехода на новую строку).\n- Новый параметр запуска "/new" (открывает RS в новом окне).\n- Новый параметр запуска "/ns" (не замораживать дочерний процесс при подключении RS к консоли процесса).\n- Теперь параметр запуска "/hide" работает и при не включенном режиме исполнения пакетного файла.\n- Новая команда "АПДЕЙТЛИСТ" (отображает список обновлений текущей версии).\n- Теперь после закрытия хоста консоли окна RS, программа будет предупреждать об этом и перезагружаться (по желанию).
RSHELL_UPDINFO_2_15=- Исправлены баги с командой "ПЕР".\n- Команда "ВЫЙТИ" переименована в "СЕССИЯ" (чтобы не было путаницы в названиях команд).\n- Команда "ВЫХОД" теперь имеет необязательный аргумент, который отвечает за код выхода.\n- Новая команда "ВЫВОДФ" (выводит содержимое файла в консоль).\n- Новая команда "ФАЙЛ.КОДИРОВКА" (устанавливает кодировку по умолчанию).\n- Новая команда "КОРЗИНА.ПЕРЕМЕСТИТЬ" (отправляет файл или папку в Корзину, если это возможно).\n- Новая команда "КОРЗИНА.ОЧИСТИТЬ" (очищает Корзину).\n- Новая операция в команде "ПЕР" под именем "ПУТЬ" (разделяет имя файла или URL на составные части).\n- Повышен лимит использования возможной памяти до 512 МБ.\n- Теперь при перенаправлении вывода через команду "ЗВЫВОД" программа пропускает ввод пользователя.\n- Теперь при перенаправлении вывода через команду "ЗВЫВОД" программа также захватывает содержимое почти любых окон RS.\n- Теперь при перенаправлении вывода через команду "ЗВЫВОД" программа сможет перехватить вывод консольных приложений, если открыть их через команду "КМД" или "ПШ".\n- Новая команда "ФАЙЛ.ПРОЧИТАТЬ.БИНАР" (читает файл в бинарном режиме).\n- Новая команда "ФАЙЛ.ЗАПИСАТЬ.БИНАР" (записывает файл в бинарном режиме).\n- Новая команда "КОДИРОВАТЬ.BASE64" (кодирует данные в base64).\n- Новая команда "ВВОД.ОКНО" (отображает поле ввода, чтобы попросить пользователя ввести строку).\n- Новая команда "ТЕКСТ.ПОКАЗАТЬ" (создает настраиваемое текстовое всплывающее окно).\n- Новая команда "ТЕКСТ.СКРЫТЬ" (удаляет существующую окно-заставку, созданную через ТЕКСТ.ПОКАЗАТЬ).\n- Новая команда "СДЕЛАТЬ" (выполняет команду).\n- Новая команда "ВЫВОДКОНСОЛЬ" или "ВК" (выполняет команду избегая графические интерфейсы RS).\n- Теперь команда "СОБРАТЬ" оптимизирует пакетный файл перед его сборкой.\n- Теперь если не указывать путь к иконке в команде "СОБРАТЬ", то будет использоваться иконка программы.\n- Теперь можно открыть справку асинхронно, подр. в справке по команде "СПРАВКА".
RSHELL_UPDINFO_2_16=- Команда "СОБРАТЬ" теперь принимает аргументы.\n- Теперь Renux Shell принимает новый параметр запуска "/COMPILE". Подр. в справке по команде "СОБРАТЬ".\n- Теперь собранные пакетные файлы Renux Shell тоже подключаются к консоли.\n- Теперь Renux Shell не меняет заголовок окна при запуске пакетного файла.\n- Теперь Renux Shell отправляет сообщение в баг-трекер, если происходит фатальная ошибка.\n- Незначительно изменен формат кода ошибки.\n- Новая команда "ИСР" или "ИДЕ" (открывает интегрированную среду разработки) [Разработка hack1exe].\n- Теперь нужно согласиться с лицензионным соглашением.
RSHELL_UPDINFO_2_16_1=- Доработана команда "ПРОГ" (важные фиксы).\n- Теперь после установки программы через "ПРОГ" создаются ярлыки: на рабочем столе и в меню Пуск.\n- Теперь IDE устаналивается через команду "ПРОГ".\n- Команда "ИДЕ" и "ИСР" были удалены.\n- Теперь ярлык Renux Shell в папке в меню Пуск.
RSHELL_UPDINFO_2_16_2=- Теперь в режиме исполнения пакетного файла проверка на новые версии не делается.\n- Теперь при удалении программ, установленных через команду ПРОГ, автоматически корректно удаляются программы, которые были ранее установлены.
RSHELL_UPDINFO_2_16_3=- Исправлена работа команды "ФУНКЦИЯ".\n- Изменено оформление лаунчера (при открытии установленных программ из команды "ПРОГ").
RSHELL_UPDINFO_2_16_4=- Мелкие фиксы и улучшения.
RSHELL_UPDINFO_2_16_5=- Оптимизация работы лаунчера Renux Shell (команда "ПРОГ").\n- Теперь при авторизации в VK через токен все сохраняется.
RSHELL_UPDINFO_2_17=- Исправлена работа команды "ПРОГ" при перенаправлении вывода консольных приложений.\n- Исправлена работа команды "ЗВЫВОД": Renux Shell не перенаправлял вывод консольных приложений, запущенные не через команду "КМД".\n- Новая команда "ОБУЧЕНИЕ" (открывает окно с обучением, где Вы научитесь пользоваться Renux Shell).\n- Теперь пункт в справке "Начало работы > Краткое обучение" переименован в "Начало работы > Обучение".\n- Теперь пункт в справке "Начало работы > Обучение" активирует команду "ОБУЧЕНИЕ".\n- Новый синтаксис Renux Shell (подробнее в команде "ОБУЧЕНИЕ").\n- Новая команда "АСИНХ" (выполняет команду во втором потоке по мере возможности (подр. см. в справке)).\n- Мелкие исправления и улучшения.
RSHELL_UPDINFO_2_18=- Мелкие фиксы и улучшения.\n- Изменен алгоритм работы обработчика команд.\n- Теперь если не введены аргументы в команде и нет авторизации в ВКонтакте, то "ВКАПИ" предложит авторизоваться, вместо того, чтобы показать формат команды.\n- Новая команда "ВКАПИ.", позволяющая стереть токен ВКонтакте из конфига и памяти процесса.\n- Новая команда "СЛУЖБЫ", позволяющая править внутренние настройки Renux Shell.\n- Изменения в переменной ".КОНСОЛЬ.РЕЗУЛЬТАТ".\n- Изменен алгоритм работы аддонов.\n- Удалена команда "ПОКА".\n- Добавлена поддержка локализаций.\n- Теперь в случае того, если команда не распознана, программа попробует проверить совместимость команды с другими локализациями.\n- Теперь при старте программы, Renux Shell переустанавливает файлы локализации во втором потоке.

// Формат документации для команд:
RSHELL_FORMAT_COMMAND_DOCUMENTATION_SYNTAX_PREFIX=Синтаксис: 
RSHELL_FORMAT_COMMAND_DOCUMENTATION_SYNTAX_PREFIX_1=Синтаксис №1:
RSHELL_FORMAT_COMMAND_DOCUMENTATION_SYNTAX_PREFIX_2=Синтаксис №2:
RSHELL_FORMAT_COMMAND_DOCUMENTATION_FORMAT_PREFIX=Формат:
RSHELL_FORMAT_COMMAND_DOCUMENTATION_EXAMPLE_PREFIX=Пример:
RSHELL_FORMAT_COMMAND_DOCUMENTATION_EXAMPLES_PREFIX=Примеры:
RSHELL_FORMAT_COMMAND_DOCUMENTATION_NOTE_PREFIX=Примечание:
RSHELL_FORMAT_COMMAND_DOCUMENTATION_NOTES_PREFIX=Примечания:
RSHELL_FORMAT_COMMAND_DOCUMENTATION_CONSOLE_RESULT_PREFIX=Переменная .КОНСОЛЬ.РЕЗУЛЬТАТ:
RSHELL_FORMAT_COMMAND_DOCUMENTATION_CONSOLE_RESULT_TEXT1=Если команда исполнена без ошибок, то переменная изменяет свое значение на "1" (единицу).
RSHELL_FORMAT_COMMAND_DOCUMENTATION_CONSOSE_RESULT_TEXT2=Команда не изменяет значение переменной / использовать не целесообразно.
RSHELL_FORMAT_COMMAND_DOCUMENTATION_CONSOLE_RESULT_TEXT3=Переменная изменяет свое значение на "1" (единицу) в любом случае.
RSHELL_FORMAT_COMMAND_DOCUMENTATION_CONSOLE_RESULT_TEXT4=Принимает значение переменной после выполнения команды.
RSHELL_FORMAT_COMMAND_DOCUMENTATION_CONSOLE_CMD_WANT_PERMISSION_ENCHANCEMENT=Команда требует повышения прав до администратора.
RSHELL_FORMAT_COMMAND_DOCUMENTATION_LAUNCH_PARAMETER_LIST_PREFIX=Список параметров запуска:
RSHELL_FORMAT_COMMAND_DOCUMENTATION_PARAMETERS_PREFIX=Параметры:

// Распространенные текстовые реакции в командах
RSHELL_TEXT_FILE_NOT_FINDED=Файл по указанному пути не найден.
RSHELL_TEXT_CANT_WRITE_FILE=Не удалось записать файл
RSHELL_TEXT_USE_TO_VIEW_DETAILS_IN_DOCS_PREFIX=Для просмотра документации по команде используйте:
RSHELL_TEXT_DONT_HAVE_PERMISSIONS_TO_USE_COMMAND=У Вас недостаточно прав для выполнения данной команды.
RSHELL_TEXT_WORKING_ONLY_IN_BATCH_MODE=Работает только в режиме исполнения пакетного файла.
RSHELL_TEXT_THIS_COMMAND_WORKING_ONLY_IN_BATCH_MODE=Данная команда работает только в режиме исполнения пакетного файла.
RSHELL_TEXT_UNKNOWN_WORD=Неизвестно
RSHELL_TEXT_REPLACE_WORD_OR=или

// Команда "АДДОН".
RSHELL_COMMAND_DOCUMENTATION_ADDON_SYNTAX=аддон
RSHELL_COMMAND_DOCUMENTATION_ADDON_DESCRIPTION=Устанавливает/удаляет/собирает аддоны.
RSHELL_COMMAND_DOCUMENTATION_ADDON_NOTES=Подробнее в справке: в разделе Аддоны.
RSHELL_COMMAND_INTERNAL_ADDON_TEXT1=Добро пожаловать в Мастер Аддонов Renux Shell.
RSHELL_COMMAND_INTERNAL_ADDON_TEXT2=Выберите операцию, которая Вам нужна:
RSHELL_COMMAND_INTERNAL_ADDON_TEXT3=Устанавливайте аддоны только из надежных источников, иначе Ваша система может быть заражена вирусом.
RSHELL_COMMAND_INTERNAL_ADDON_TEXT4=Список аддонов:
RSHELL_COMMAND_INTERNAL_ADDON_TEXT5=Аддон с таким именем не найден.
RSHELL_COMMAND_INTERNAL_ADDON_TEXT6=Аддон удален.
RSHELL_COMMAND_INTERNAL_ADDON_ACTION_INSTALL=установить аддон
RSHELL_COMMAND_INTERNAL_ADDON_ACTION_UNINSTALL=удалить аддон
RSHELL_COMMAND_INTERNAL_ADDON_ACTION_COMPILE=собрать аддон
RSHELL_COMMAND_INTERNAL_ADDON_ACTION_EXIT=выйти
RSHELL_COMMAND_INTERNAL_ADDON_ACTION_DELETE_BY_FILE_NAME=Укажите имя файла аддона для удаления
RSHELL_COMMAND_INTERNAL_ADDON_ACTION_ENTER_PATH_TO_FUTURE_FILE=Укажите путь к будущему файлу (без расширения), в который будет записан собранный аддон
RSHELL_COMMAND_INTERNAL_ADDON_ENTER_PATH_TO_FILE=Укажите путь к файлу
RSHELL_COMMAND_INTERNAL_ADDON_SUCCESSFUL_COMPILED=Аддон собран и сохранен по пути %1.
RSHELL_COMMAND_INTERNAL_ADDON_TEXT7=Поддерживается максимум 15 параметров.
RSHELL_COMMAND_INTERNAL_ADDON_TEXT8=Файл %1 не найден.
RSHELL_COMMAND_INTERNAL_ADDON_TEXT9_PREFIX=Загружен аддон:

// Команда "СЕССИЯ".
RSHELL_COMMAND_DOCUMENTATION_SHUTDOWN_SYNTAX=сессия <код>
RSHELL_COMMAND_DOCUMENTATION_SHUTDOWN_DESCRIPTION=Завершит работу/выйдет из системы и т.п.\n\nФлаги (код):\n0 = выход из системы\n1 = завершение работы\n2 = перезапуск\n3 = принудительно\n4 = выключить\n5 = синий экран смерти\n0 = отменить запланированное завершение работы
RSHELL_COMMAND_DOCUMENTATION_SHUTDOWN_NOTES=Значение «принудительно» (3) принудительно закрывает все открытые приложения. Его следует использовать только в экстренных случаях, поскольку это может привести к потере данных любыми открытыми приложениями.\n  Значение «выключить» (4) выключает систему и отключает питание.\n  Значение «синий экран смерти (5)» вызывает синий экран смерти, методом завершения системного процесса. Это может привести к потери данных любыми открытыми приложениями.
RSHELL_COMMAND_DOCUMENTATION_SHUTDOWN_EXAMPLE=сессия 1

// Команда "МЕТКА".
RSHELL_COMMAND_DOCUMENTATION_LABEL_SYNTAX=метка <название метки>:
RSHELL_COMMAND_DOCUMENTATION_LABEL_DESCRIPTION=Символьное имя, на которое обычно должен осуществляться переход.
RSHELL_COMMAND_DOCUMENTATION_LABEL_EXAMPLE=// Для отсчета кол-ва раз активации\n  пер а = 1\n  \n  // Объявление метки под именем "лучшая_метка_в_мире".\n  метка лучшая_метка_в_мире:\n  \n  // Выводим текст о том, что активировалась метка\n  вывод Активация метки под именем "лучшая_метка_в_мире" (№%а%)\n  \n  // Добавляем переменной "а" единицу.\n  пер а += 1\n  \n  // Выполняем переход к метке "лучшая_метка_в_мире"\n  перейти лучшая_метка_в_мире
RSHELL_COMMAND_DOCUMENTATION_LABEL_TEXT1=Метка с таким именем не может быть создана (#НПП).
RSHELL_COMMAND_DOCUMENTATION_LABEL_TEXT2=Метка с таким именем не может быть создана (#%1).
RSHELL_COMMAND_DOCUMENTATION_LABEL_TEXT3=Метка %1#%2 зарегистрирована в памяти процесса.

// Команда "ГК".
RSHELL_COMMAND_DOCUMENTATION_HKEYS_SYNTAX=гк <клавиша/клавиши>:
RSHELL_COMMAND_DOCUMENTATION_HKEYS_DESCRIPTION=Представляет собой метку (как в команде МЕТКА), которая активирует свое выполнение при нажатии определенных клавиш.
RSHELL_COMMAND_DOCUMENTATION_HKEYS_TEXT1=С помощью Renux Shell Вы можете создавать свои макросы. Перед двоеточием указывается "гк ", затем клавиша или сочетание клавиш через запятую, вызывающие действие. После действий горячей клавиши нужно указать слово "конец", чтобы программа не продолжала выполнять сценарий дальше.
RSHELL_COMMAND_DOCUMENTATION_HKEYS_TEXT2=ОБРАТИТЕ ВНИМАНИЕ: если Вы хотите прекратить выполнение сценария, оставив Renux в режиме ожидания нажатия следующих горячих клавиш, то используйте команду "КОНЕЦ".
RSHELL_COMMAND_DOCUMENTATION_HKEYS_EXAMPLE=гк Alt,1:\n  вывод Вы нажали на Alt,1\n  ждать.время 5000\n  конец
RSHELL_COMMAND_INTERNAL_HKEYS_TEXT1=Горячая клавиша %1#%2 зарегистрирована в памяти процесса.

// Команда "КОНЕЦ".
RSHELL_COMMAND_DOCUMENTATION_END_SYNTAX=конец
RSHELL_COMMAND_DOCUMENTATION_END_DESCRIPTION=Останавливает исполнение макрокоманды.
RSHELL_COMMAND_DOCUMENTATION_END_EXAMPLE=гк Alt,1:\n  вывод нажата горячая клавиша Alt+1\n  конец\n  вывод Эта строка не выводится.
RSHELL_COMMAND_INTERNAL_END_TEXT1=Функция %1 зарегистрирована в памяти процесса.

// Команда "ПЕРЕЙТИ".
RSHELL_COMMAND_DOCUMENTATION_GOTO_SYNTAX=перейти <название метки>
RSHELL_COMMAND_DOCUMENTATION_GOTO_DESCRIPTION=Безусловный переход к определенной точке сценария, обозначенной меткой.
RSHELL_COMMAND_DOCUMENTATION_GOTO_EXAMPLE=// Для отсчета кол-ва раз активации\n  пер а = 1\n\n  // Объявление метки под именем "лучшая_метка_в_мире".\n  метка лучшая_метка_в_мире:\n\n  // Выводим текст о том, что активировалась метка\n  вывод Активация метки под именем "лучшая_метка_в_мире" (№%а%)\n\n  // Добавляем переменной "а" единицу.\n  пер а += 1\n\n  // Выполняем переход к метке "лучшая_метка_в_мире"\n  перейти лучшая_метка_в_мире
RSHELL_COMMAND_DOCUMENTATION_GOTO_TEXT1=Метка %1 не найдена.
RSHELL_COMMAND_DOCUMENTATION_GOTO_TEXT2=Переход на %1 успешен.

// Команда "ИНФОРМАЦИЯ".
RSHELL_COMMAND_INTERNAL_INFORMATION_TEXT=Renux Shell (командная строка), версия %1.
RSHELL_COMMAND_INTERNAL_INFORMATION_TEXT_TO_DEBUG_PREFIX=Информация о последней версии (на сервере):
RSHELL_COMMAND_INTERNAL_INFORMATION_TEXT_BETA=Тс... никому не говорите о том, что в новом обновлении.
RSHELL_COMMAND_DOCUMENTATION_INFORMATION_DESCRIPTION=Выводит информацию о Renux Shell.
RSHELL_COMMAND_DOCUMENTATION_INFORMATION_EXAMPLE=информация
RSHELL_COMMAND_DOCUMENTATION_INFORMATION_SYNTAX1=информация
RSHELL_COMMAND_DOCUMENTATION_INFORMATION_SYNTAX2=инфо

// Команда "КОНСОЛЬ".
RSHELL_COMMAND_DOCUMENTATION_CONSOLE_DESCRIPTION=Установщик Renux Shell, позволяющий установить/удалить Renux Shell.
RSHELL_COMMAND_DOCUMENTATION_CONSOLE_SYNTAX=консоль <команда>
RSHELL_COMMAND_DOCUMENTATION_CONSOLE_PARAMS=установить - установит Renux Shell на Ваш ПК.\n  удалить - удалит Renux Shell с Вашего ПК.\n  обновить - автоматическое применение текущей версии Renux Shell.
RSHELL_COMMAND_DOCUMENTATION_CONSOLE_EXAMPLES=консоль установить\n  консоль удалить\n  консоль обновить
RSHELL_COMMAND_INTERNAL_CONSOLE_TEXT1=ОБНОВИТЬ
RSHELL_COMMAND_INTERNAL_CONSOLE_TEXT2=Renux Shell не установлен.
RSHELL_COMMAND_INTERNAL_CONSOLE_TEXT3_PREFIX=Версия программы, которая будет установлена:
RSHELL_COMMAND_INTERNAL_CONSOLE_TEXT4_PREFIX=Копирование файла
RSHELL_COMMAND_INTERNAL_CONSOLE_TEXT5=Перерегистрация расширения *.rs в системном реестре...
RSHELL_COMMAND_INTERNAL_CONSOLE_TEXT6=Перерегистрация Renux Shell в системном реестре...
RSHELL_COMMAND_INTERNAL_CONSOLE_TEXT7=Исполняемый файл Renux Shell
RSHELL_COMMAND_INTERNAL_CONSOLE_TEXT8=Создание ярлыка на рабочем столе...
RSHELL_COMMAND_INTERNAL_CONSOLE_TEXT9=Добавление ярлыка в меню Пуск...
RSHELL_COMMAND_INTERNAL_CONSOLE_TEXT10=Обновление завершено. На рабочем столе появился ярлык программы. Запускайте Renux Shell с помощью него.
RSHELL_COMMAND_INTERNAL_CONSOLE_TEXT11=УСТАНОВИТЬ
RSHELL_COMMAND_INTERNAL_CONSOLE_TEXT12=Вы уже установили Renux Shell.
RSHELL_COMMAND_INTERNAL_CONSOLE_TEXT13=Регистрация расширения *.rs в системном реестре...
RSHELL_COMMAND_INTERNAL_CONSOLE_TEXT14=Запустить Renux Shell
RSHELL_COMMAND_INTERNAL_CONSOLE_TEXT15=Регистрация Renux Shell в системном реестре...
RSHELL_COMMAND_INTERNAL_CONSOLE_TEXT16=Добавление в переменные окружения (переменная PATH)...
RSHELL_COMMAND_INTERNAL_CONSOLE_TEXT17=Установка завершена. На рабочем столе появился ярлык программы. Запускайте Renux Shell с помощью него.
RSHELL_COMMAND_INTERNAL_CONSOLE_TEXT18=УДАЛИТЬ
RSHELL_COMMAND_INTERNAL_CONSOLE_TEXT19=Вы еще не установили Renux Shell.
RSHELL_COMMAND_INTERNAL_CONSOLE_TEXT20=Внимание: удаление Renux Shell повлечёт за собой удаление всех программ, установленных Renux Shell. Удалить? [Y/N]
RSHELL_COMMAND_INTERNAL_CONSOLE_TEXT21=Откат регистрации расширения *.rs в системном реестре...
RSHELL_COMMAND_INTERNAL_CONSOLE_TEXT22=Откат регистрации Renux Shell в системном реестре...
RSHELL_COMMAND_INTERNAL_CONSOLE_TEXT23_PREFIX=Откат установки программы
RSHELL_COMMAND_INTERNAL_CONSOLE_TEXT24=Не удалось удалить папку по пути:
RSHELL_COMMAND_INTERNAL_CONSOLE_TEXT25=Удаление ярлыка в меню Пуск...
RSHELL_COMMAND_INTERNAL_CONSOLE_TEXT26=Программа удалена. Спасибо за использование.
RSHELL_COMMAND_INTERNAL_CONSOLE_TEXT27=Недопустимый параметр команды.

// Команда "СПРАВКА.
RSHELL_COMMAND_DOCUMENTATION_DOCS_SYNTAX1=справка [имя команды]
RSHELL_COMMAND_DOCUMENTATION_DOCS_SYNTAX2=? [имя команды]
RSHELL_COMMAND_DOCUMENTATION_DOCS_TEXT=Если параметр опускается, то открывает руководство по работе с программой Renux Shell в виде окна с графическим пользовательским интерфейсом.\nЕсли параметр указан, то производит поиск справки по указанной команде.\nЕсли в параметре указано "." (точка), то открывает справку асинхронно.
RSHELL_COMMAND_DOCUMENTATION_DOCS_NOTES=Для сокращения команды, Вы можете использовать вместо слова "СПРАВКА" - знак "?".\n  Также Вы можете указать в конце команды вопросительный знак, чтобы открыть справку про нее.
RSHELL_COMMAND_DOCUMENTATION_DOCS_EXAMPLES=справка\n  ?\n  справка адз\n  ? адз\n  адз?\n  мышь.передвинуть?\n  вывод?

// Команда "ФУНКЦИЯ".
RSHELL_COMMAND_DOCUMENTATION_FUNC_SYNTAX=функция <имя>:
RSHELL_COMMAND_DOCUMENTATION_FUNC_DESCRIPTION=Исполняет макрокоманду, указанную после имени функции и продолжает выполнение, пока не сталкивается с "КОНЕЦ".
RSHELL_COMMAND_DOCUMENTATION_FUNC_NOTE=функция выполняется только тогда, когда ее вызывают по имени.
RSHELL_COMMAND_DOCUMENTATION_FUNC_EXAMPLE=// Объявление функции под именем "плюс_один", которая будет добавлять к переменной "а" единицу.\n  функция плюс_один:\n  пер а += 1\n  конец\n  \n  метка цикл:\n  // Вызваем функцию "плюс_один" просто указав ее имя.\n  плюс_один\n  перейти цикл
RSHELL_COMMAND_DOCUMENTATION_FUNC_EXAMPLE_SHORT=функция имя_функции:
RSHELL_COMMAND_DOCUMENTATION_FUNC_NOTE_LONG=В конце сценария функции используйте команду "КОНЕЦ".\nВызвать функцию можно именем функции (т.е. если имя функции "самая_лучшая_функция_в_мире", то и чтобы ее вызвать, нужно в сценарии указать "самая_лучшая_функция_в_мире).
RSHELL_COMMAND_DOCUMENTATION_FUNC_EXAMPLE_PART_OF_SCRIPT=Пример "кусочка" сценария:
RSHELL_COMMAND_DOCUMENTATION_FUNC_TEXT1=Команда '%1' не может быть выполнена (нельзя создавать метки, горячие клавиши, функции и переход к ним в функции).
RSHELL_COMMAND_DOCUMENTATION_FUNC_TEXT2=Обнаружена функция %1.

// Команда "АДЗ".
RSHELL_COMMAND_DOCUMENTATION_ADZ_SYNTAX=адз <параметр>
RSHELL_COMMAND_DOCUMENTATION_ADZ_DESCRIPTION=> Так как программа (Renux Shell) принимает аргументы (параметры) при старте программы, то команда АДЗ (аббр. "Аргумент До Запуска") позволяет вводить их после запуска программы.\nПример того, как Вы можете запустить режим отладки в программе, указав параметр запуска:\n\n  1. Откройте командную строку в папке программы.\n  2. Укажите команду: rshell.exe /debug\n  3. Нажмите клавишу Enter.\n\nЧтобы не открывать командную строку и т.п., Вы можете указать параметр запуска после команды "АДЗ".\nТот же режим отладки можно вызвать, указав команду в Renux'e:\n  адз /debug
RSHELL_COMMAND_DOCUMENTATION_ADZ_LAUNCH_PARAM_LIST=Список параметров запуска:
RSHELL_COMMAND_DOCUMENTATION_ADZ_LAUNCH_PARAM_LIST_TEXT=/hide - выполняться полностью в фоновом режиме. Работает только в режиме исполнения пакетного файла.\n  /ignore_errors - игнорировать ошибки (работает только для режима исполнения файла).\n  /ignore_warnings - игнорировать предупреждения (работает только для режима исполнения файла).\n  /output_mode:<msg/print> - изменить режим вывода сообщений об ошибках/предупреждениях/информации (msg - в диалоговое окно, print - в консоль).\n  /debug - режим отладки, показывает дополнительную информацию.\n  /log - записывать в файл лог содержимое консоли.\n  /new - открыть RS в новом окне.\n  /ns - не замораживать дочерний процесс при подключении RS к консоли процесса.\n  /compile - см. справку по команде "СОБРАТЬ" (для быстрого вызова введите команду "СОБРАТЬ?").
RSHELL_COMMAND_DOCUMENTATION_ADZ_EXAMPLE=адз /debug
RSHELL_COMMAND_DOCUMENTATION_ADZ_TEXT=Аргументы командной строки (регистр букв не имеет значения) см. в справке.

// Команда "АДМИН".
RSHELL_COMMAND_DOCUMENTATION_ADMIN_SYNTAX=админ
RSHELL_COMMAND_DOCUMENTATION_ADMIN_DESCRIPTION=Перезапускает Renux Shell от имени администратора.
RSHELL_COMMAND_DOCUMENTATION_ADMIN_EXAMPLE=админ
RSHELL_COMMAND_DOCUMENTATION_ADMIN_ERROR_TEXT=Не удалось получить права администратора. Возможно, это связанно из-за установленныхх параметров контроля учетных записей. Попробуйте запустить программу от имени администратора вручную через контекстное меню при нажатии ярлык программы.

// Команда "ВВОД".
RSHELL_COMMAND_DOCUMENTATION_INPUT_SYNTAX=ввод <имя переменной>
RSHELL_COMMAND_DOCUMENTATION_INPUT_DESCRIPTION=Ожидает ввод данных пользователя и записывает введенные данные в переменную.
RSHELL_COMMAND_DOCUMENTATION_INPUT_EXAMPLE=ввод а

// Команда "ВЫВОД".
RSHELL_COMMAND_DOCUMENTATION_OUTPUT_SYNTAX=вывод <текст>
RSHELL_COMMAND_DOCUMENTATION_OUTPUT_DESCRIPTION=Выводит указанный текст в консоль (с новой строки).
RSHELL_COMMAND_DOCUMENTATION_OUTPUT_EXAMPLE=вывод Привет, Мир!

// Команда "ОБУЧЕНИЕ".
RSHELL_COMMAND_DOCUMENTATION_TUTORIAL_SYNTAX=обучение
RSHELL_COMMAND_DOCUMENTATION_TUTORIAL_DESCRIPTION=Открывает окно с обучением, где Вы научитесь пользоваться Renux Shell.
RSHELL_COMMAND_DOCUMENTATION_TUTORIAL_NOTE=Окно обучения открывается асинхронно, так что перехватить его через ЗВЫВОД или ВК не является возможным.
RSHELL_COMMAND_INTERNAL_TUTORIAL_ERROR=Не удалось запустить обучение.

// Команда "АПДЕЙТЛИСТ".
RSHELL_COMMAND_DOCUMENTATION_UPDATELIST_SYNTAX=апдейтлист
RSHELL_COMMAND_DOCUMENTATION_UPDATELIST_DESCRIPTION=Отображает список обновлений текущей версии.

// Команда "АСИНХ".
RSHELL_COMMAND_DOCUMENTATION_ASYNC_SYNTAX=асинх '<команда>' '[имя переменной для вывода .КОНСОЛЬ.РЕЗУЛЬТАТ]'
RSHELL_COMMAND_DOCUMENTATION_ASYNC_DESCRIPTION=Выполняет команду во втором потоке по мере возможности (если ожидается ввод от пользователя в консоли, то выполняется после ввода).
RSHELL_COMMAND_DOCUMENTATION_ASYNC_NOTE=Команда АСИНХ не может содержать в себе еще одну команду АСИНХ, так как случится перезапись АСИНХ и во втором потоке выполнится только последняя команда, указанная в АСИНХ.
RSHELL_COMMAND_DOCUMENTATION_ASYNC_EXAMPLE=асинх 'вывод Тестирование асинхронного выполнения.' 'результат'

// Команда "ВЫВОДБ".
RSHELL_COMMAND_DOCUMENTATION_OUTPUTL_SYNTAX=выводб <текст>
RSHELL_COMMAND_DOCUMENTATION_OUTPUTL_DESCRIPTION=Выводит указанный текст в консоль (без новой строки).
RSHELL_COMMAND_DOCUMENTATION_OUTPUTL_EXAMPLE=выводб Привет, Мир!

// Команда "ВЫВОДКОНСОЛЬ".
RSHELL_COMMAND_DOCUMENTATION_OUTCON_SYNTAX=выводконсоль <команда>
RSHELL_COMMAND_DOCUMENTATION_OUTCON_EXAMPLE=выводконсоль ??
RSHELL_COMMAND_INTERNAL_OUTCON_ERROR=Недопустимая операция в режиме перенаправления вывода консоли.
RSHELL_COMMAND_DOCUMENTATION_OUTCON_DESCRIPTION=Выполняет команду избегая графические интерфейсы RS.
RSHELL_COMMAND_DOCUMENTATION_OUTCON_PARAMETERS=<команда> - указывается команда, которую нужно выполнить.

// Команда "ЗАГОЛОВОК".
RSHELL_COMMAND_DOCUMENTATION_TITLE_SYNTAX=заголовок <новый заголовок>
RSHELL_COMMAND_DOCUMENTATION_TITLE_DESCRIPTION=Изменяет заголовок главного окна Renux Shell.
RSHELL_COMMAND_DOCUMENTATION_TITLE_EXAMPLE=заголовок Новый заголовок

// Команда "ЗВЫВОД".
RSHELL_COMMAND_DOCUMENTATION_WOUTPUT_SYNTAX=звывод [параметр вывода]
RSHELL_COMMAND_DOCUMENTATION_WOUTPUT_DESCRIPTION=Изменяет режим вывода сообщений Renux.
RSHELL_COMMAND_DOCUMENTATION_WOUTPUT_OUTPUT_PARAM_PREFIX=Параметр вывода:
RSHELL_COMMAND_DOCUMENTATION_WOUTPUT_OUTPUT_PARAM=Если опустить параметр, то вывод будет перенаправлен в консоль (по-умолчанию).\n  Если первым символом с левой стороны является ":", то вывод будет перенаправлен в переменную, чье имя указано после ":").*\n  Если параметр указан без первого символа (как в пункте со звездочкой) и не опущен, то вывод будет перенаправлен в файл, чей путь Вы укажете в этом аргументе.
RSHELL_COMMAND_DOCUMENTATION_WOUTPUT_NOTE=Данная команда перенаправляет сообщения только от этой программы! Другие консольные приложения, запущенные из Renux Shell перенаправляться не будут!\n  Если Вы объявляете в [параметр вывода] путь к файлу, то сначала он будет удален, после уже начнется процесс перенаправления вывода в этот файл.\n  Пустые строки в вывод не записываются!\n  Быстродействие программы может снизиться, пока вывод перенаправляется!\n  Renux Shell будет отменять ожидание какого-либо ввода пользователя, пока перенаправление активно!\n  Программа будет читать содержимое дополнительных окон RS, записывать их содержимое в вывод и закрывать эти окна.\n  Если Вам нужно перенаправить вывод из консольных приложений, то воспользуйтесь встроенной командой "КМД".
RSHELL_COMMAND_DOCUMENTATION_WOUTPUT_EXAMPLE_OUTPUT_TO_VARIABLE_PREFIX=Пример с перенаправлением вывода в переменную:
RSHELL_COMMAND_DOCUMENTATION_WOUTPUT_EXAMPLE_OUTPUT_TO_VARIABLE=звывод :запись_вывода_команды_дир\n  дир\n  звывод\n  вывод %запись_вывода_команды_дир%
RSHELL_COMMAND_DOCUMENTATION_WOUTPUT_EXAMPLE=звывод log.txt\n  дир\n  звывод\n  log.txt

// Команда "ПАУЗА".
RSHELL_COMMAND_DOCUMENTATION_PAUSE_SYNTAX=пауза
RSHELL_COMMAND_DOCUMENTATION_PAUSE_DESCRIPTION=Ожидает нажатие буквы/цифры на клавиатуре.

// Команда "ПРОЗРАЧНОСТЬ".
RSHELL_COMMAND_DOCUMENTATION_TRANSPARENT_SYNTAX=прозрачность <целое число>
RSHELL_COMMAND_DOCUMENTATION_TRANSPARENT_DESCRIPTION=Изменяет прозрачность окна командной строки Renux Shell.
RSHELL_COMMAND_DOCUMENTATION_TRANSPARENT_EXAMPLE=прозрачность 240
RSHELL_COMMAND_INTERNAL_TRANSPARENT_TEXT1=Первый аргумент должен быть целым числом.
RSHELL_COMMAND_INTERNAL_TRANSPARENT_TEXT2=Число из первого аргумента должно быть в диапазоне от 100 до 255.

// Команда "СДЕЛАТЬ".
RSHELL_COMMAND_DOCUMENTATION_DO_SYNTAX=сделать <команда>
RSHELL_COMMAND_DOCUMENTATION_DO_EXAMPLE=сделать вывод Привет
RSHELL_COMMAND_DOCUMENTATION_DO_DESCRIPTION=Выполняет команду.
RSHELL_COMMAND_DOCUMENTATION_DO_PARAMETERS=<команда> - указывается команда, которую нужно выполнить.

// Команда "СЛУЖБЫ".
RSHELL_COMMAND_DOCUMENTATION_SVC_SYNTAX=службы
RSHELL_COMMAND_DOCUMENTATION_SVC_DESCRIPTION=Позволяет править внутренние настройки (конфиг) Renux Shell в консольном режиме.
RSHELL_COMMAND_DOCUMENTATION_SVC_NOTE=Ничего не меняйте, если ничего не понимаете. Это может привезти к нестабильной работе программы.
RSHELL_COMMAND_DOCUMENTATION_SVC_EXAMPLE=службы
RSHELL_COMMAND_INTERNAL_SVC_WORD_NUMBER=Номер
RSHELL_COMMAND_INTERNAL_SVC_NAME_OF_SERVICE_TEXT=Имя службы
RSHELL_COMMAND_INTERNAL_SVC_WORD_DESCRIPTION=Описание
RSHELL_COMMAND_INTERNAL_SVC_TEXT=Укажите номер службы для взаимодействия с ней:

// Служба "ПРАВА.КОМАНДА".
RSHELL_SERVICE_PERMISSIONS_COMMAND_NAME=ПРАВА.КОМАНДА
RSHELL_SERVICE_PERMISSIONS_COMMAND_DESCRIPTION=Служба назначения необходимых прав для выполнения команд.
RSHELL_SERVICE_PERMISSIONS_COMMAND_STARTED_TEXT=Запущена служба назначения необходимых прав для выполнения команд.
RSHELL_SERVICE_PERMISSIONS_COMMAND_TEXT1=Команды, которые будут работать только с правами администратора: %1.
RSHELL_SERVICE_PERMISSIONS_COMMAND_TEXT2=Изменить список запрещенных команд? [Y-да/N-нет/S-стандарт]
RSHELL_SERVICE_PERMISSIONS_COMMAND_TEXT3=Перечисляйте команды через пробел. Эти команды будут выполняться только если программа будет запущена от имени администратора.
RSHELL_SERVICE_PERMISSIONS_COMMAND_TEXT_ALL_COMMANDS_ALLOWED=все команды разрешены
RSHELL_SERVICE_PERMISSIONS_COMMAND_TEXT4_PREFIX=Применено. Теперь
RSHELL_SERVICE_PERMISSIONS_COMMAND_TEXT4=эти команды не будут выполняться без прав администратора:
RSHELL_SERVICE_PERMISSIONS_COMMAND_TEXT5=будут выполняться все команды

// Служба "ПАРСЕР.ПАРАМЕТРЫ".
RSHELL_SERVICE_PARSER_PARAMS_NAME=ПАРСЕР.ПАРАМЕТРЫ
RSHELL_SERVICE_PARSER_PARAMS_DESCRIPTION=Служба назначения новых параметров работы обработчика команд RS.
RSHELL_SERVICE_PARSER_PARAMS_STARTED_TEXT=Запущена служба назначения новых параметров работы обработчика команд RS.
RSHELL_SERVICE_PARSER_PARAMS_TEXT1=- На данный момент обработчик команд %1 наличие необходимых аргументов.
RSHELL_SERVICE_PARSER_PARAMS_TEXT2=игнорирует
RSHELL_SERVICE_PARSER_PARAMS_TEXT3=требует
RSHELL_SERVICE_PARSER_PARAMS_TEXT4_PREFIX=- Переменная обозначается знаком:
RSHELL_SERVICE_PARSER_PARAMS_TEXT5=Изменить текущие параметры? [Y-да/N-нет]
RSHELL_SERVICE_PARSER_PARAMS_TEXT6=1) Игнорировать/требовать наличие необходимых аргументов.\n2) Изменить знак, обозначающий переменную.
RSHELL_SERVICE_PARSER_PARAMS_TEXT7=\nВыберите параметр для изменения (нужно указать число):
RSHELL_SERVICE_PARSER_PARAMS_TEXT8=Игнорировать наличие необходимых аргументов? [Y-игнорировать/N-требовать]
RSHELL_SERVICE_PARSER_PARAMS_TEXT9=Применено. Теперь обработчик команд %1 наличие необходимых аргументов.
RSHELL_SERVICE_PARSER_PARAMS_TEXT10=Изменить знак обозначения переменной (крайне не рекомендуется)? [Y-да/N-нет/S-стандарт]
RSHELL_SERVICE_PARSER_PARAMS_TEXT11=\nУкажите ОДИН символ, который будет обозначать переменную:
RSHELL_SERVICE_PARSER_PARAMS_TEXT12=Этот символ не может обозначать переменную.
RSHELL_SERVICE_PARSER_PARAMS_TEXT13_PREFIX=Применено. Теперь данный символ обозначает переменную:
RSHELL_SERVICE_PARSER_PARAMS_TEXT14=Не удалось распознать номер действия.

// Служба "СТАРТ.КОМАНДА".
RSHELL_SERVICE_START_COMMAND_NAME=СТАРТ.КОМАНДА
RSHELL_SERVICE_START_COMMAND_DESCRIPTION=Служба назначения команды для выполнения при запуске Renux Shell.
RSHELL_SERVICE_START_COMMAND_STARTED_TEXT=Запущена служба назначения команды для выполнения при запуске Renux Shell.
RSHELL_SERVICE_START_COMMAND_TEXT1=Команда, которая выполняется при запуске: %1.
RSHELL_SERVICE_START_COMMAND_TEXT2=<нет>
RSHELL_SERVICE_START_COMMAND_TEXT3=\nИзменить команду? [Y-да/N-нет/S-стандарт]
RSHELL_SERVICE_START_COMMAND_TEXT4_PREFIX=Укажите команду, которая будет выполняться при запуске RS:
RSHELL_SERVICE_START_COMMAND_TEXT5_PREFIX=Применено. Теперь при запуске программы будет выполняться команда:

// Служба "ВКАПИ.ПРОКСИ".
RSHELL_SERVICE_VKAPI_PROXY_NAME=ВКАПИ.ПРОКСИ
RSHELL_SERVICE_VKAPI_PROXY_DESCRIPTION=Служба назначения нового прокси для команды 'ВКАПИ'.
RSHELL_SERVICE_VKAPI_PROXY_STARTED_TEXT=Запущена служба назначения нового прокси для команды 'ВКАПИ'.
RSHELL_SERVICE_VKAPI_PROXY_TEXT1=Текущая настройка прокси для ВК: %1.
RSHELL_SERVICE_VKAPI_PROXY_TEXT2=<нет>
RSHELL_SERVICE_VKAPI_PROXY_TEXT3=\nИзменить прокси? [Y-да/N-нет/S-стандарт]
RSHELL_SERVICE_VKAPI_PROXY_TEXT4_PREFIX=Укажите новое прокси:
RSHELL_SERVICE_VKAPI_PROXY_TEXT5=Эта строка не может быть прокси.
RSHELL_SERVICE_VKAPI_PROXY_TEXT6_PREFIX=Применено. Теперь запросы к VK API проходят через:
RSHELL_SERVICE_VKAPI_PROXY_TEXT7=Не удалось распознать номер службы.

// Команда "ВКАПИ.".
RSHELL_COMMAND_DOCUMENTATION_VKAPI_RESET_SYNTAX=ВКАПИ.
RSHELL_COMMAND_DOCUMENTATION_VKAPI_RESET_DESCRIPTION=Стирает информацию о токене VK с текущего ПК.
RSHELL_COMMAND_DOCUMENTATION_VKAPI_RESET_EXAMPLE=вкапи.
RSHELL_COMMAND_INTERNAL_VKAPI_RESET_TEXT1=Вы еще не вошли в аккаунт.
RSHELL_COMMAND_INTERNAL_VKAPI_RESET_TEXT2=Токен для работы с VK API успешно очищен из конфига и памяти процесса.

// Команда "ПОДСКАЗКА".
RSHELL_COMMAND_DOCUMENTATION_TOOLTIP_SYNTAX=подсказка '[текст]' '[x]' '[y]' '[id]'
RSHELL_COMMAND_DOCUMENTATION_TOOLTIP_DESCRIPTION=Создаёт окно, которое всегда будет поверх всех окон.
RSHELL_COMMAND_DOCUMENTATION_TOOLTIP_PARAMETERS=[текст] = Если поле пустое или пропущено, существующая подсказка (если есть) будет скрыта. В противном случае этот параметр является текстом, отображаемым во всплывающей подсказке.\n  [x] и [y] = Положение X и Y всплывающей подсказки относительно экрана. Если координаты опущены, всплывающая подсказка будет показана рядом с курсором мыши.\n  [id] = Опустите этот параметр, если вам не нужно, чтобы несколько всплывающих подсказок появлялись одновременно. В противном случае это число от 1 до 20, указывающее, над каким окном всплывающей подсказки работать. Если не указано, то это число 1 (первое).
RSHELL_COMMAND_DOCUMENTATION_TOOLTIP_NOTES=Если координаты X и Y приведут к тому, что всплывающая подсказка исчезнет с экрана, она будет полностью видна.\n  Подсказка отображается, пока не произойдет одно из следующих действий:\n  - Сценарий заканчивается.\n  - Команда ПОДСКАЗКА выполняется снова с пустым параметром [текст].\n  - Пользователь нажимает на всплывающую подсказку (это может зависеть от версии операционной системы).
RSHELL_COMMAND_DOCUMENTATION_TOOLTIP_EXAMPLE=подсказка 'Подсказка с текстом отображается рядом с мышью'\n  ждать.время 5000\n  подсказка 'Подсказка с текстом отображается по координатам X и Y (100, 100)' '100' '100'\n  ждать.время 5000\n  подсказка 'Подсказка №1' '100' '100' '1'\n  подсказка 'Подсказка №2' '100' '150' '2'\n  подсказка 'Подсказка №3' '100' '200' '3'\n  подсказка '' '' '' '1'; подсказка '' '' '' '2'; подсказка '' '' '' '3';

// Команда "ТЕКСТ.СКРЫТЬ".
RSHELL_COMMAND_DOCUMENTATION_STEXTOFF_SYNTAX=текст.скрыть
RSHELL_COMMAND_DOCUMENTATION_STEXTOFF_DESCRIPTION=Удаляет существующую окно-заставку, созданную через ТЕКСТ.ПОКАЗАТЬ.

// Команда "ТЕКСТ.ПОКАЗАТЬ".
RSHELL_COMMAND_DOCUMENTATION_STEXTON_SYNTAX=текст.показать '[ширина]' '[высота]' '[заголовок]' '[текст]'
RSHELL_COMMAND_DOCUMENTATION_STEXTON_DESCRIPTION=Создает настраиваемое текстовое всплывающее окно.
RSHELL_COMMAND_DOCUMENTATION_STEXTON_PARAMETERS=<ширина> = Ширина в пикселях окна. По умолчанию 200.\n  <высота> = Высота в пикселях окна (не включая строку заголовка). По умолчанию 0 (то есть будет показана только строка заголовка).\n  <заголовок> = Название окна. По умолчанию пусто.\n  <текст> = Текст окна. По умолчанию пусто. Если текст длинный, его можно разбить на несколько более коротких строк с помощью продолжения, что может улучшить читаемость и удобство обслуживания.
RSHELL_COMMAND_DOCUMENTATION_STEXTON_NOTES=Чтобы максимально изменять макет и имя/цвет/размер шрифта, используйте команду ТЕКСТ.ПОКАЗАТЬ с опцией zh0, которая пропускает панель и отображает только текст. Например: ТЕКСТ.ПОКАЗАТЬ 'zh0 fs18' 'Шрифт (18 пунктов)' '' ''.\n  Используйте команду ТЕКСТ.СКРЫТЬ, чтобы удалить существующее окно-заставку.\n  Всплывающее окно "всегда сверху", что означает, что оно остается над всеми другими обычными окнами.\n  Для этой команды возможно только одно окно в одну сессию Renux Shell.
RSHELL_COMMAND_DOCUMENTATION_STEXTON_EXAMPLES=текст.показать '' '' 'Отображает только строку заголовка.' ''\n  ждать.время 3000\n  текст.показать '' '' 'Буфер обмена' '%.система.клипборд%'\n  ждать.время 3000\n  текст.скрыть

// Команда "ВВОД.ОКНО".
RSHELL_COMMAND_DOCUMENTATION_INPUTBOX_SYNTAX=ввод.окно '<вывод (имя переменной)>' '<заголовок>' '<текст>' '[скрывать? (flag=0/1)]' '[ширина]' '[высота]' '[x]' '[y]' '[имя шрифта]' '[тайм-аут]' '[текст по-умолчанию]'
RSHELL_COMMAND_DOCUMENTATION_INPUTBOX_DESCRIPTION=Отображает поле ввода, чтобы попросить пользователя ввести строку.
RSHELL_COMMAND_DOCUMENTATION_INPUTBOX_PARAMETERS=<вывод> = Имя переменной, в которую будет помещена введенная пользователем строка.\n  <заголовок> = Заголовок окна скрипта.\n  <текст> = Поясняющий текст, отображаемый в окне. Может подсказывать пользователю, что от него требуется. Если текст длинный- его можно разбить при помощи секции переноса ``n.\n  [скрывать?] = Если указать "1" - ввод будет замаскирован. Обычно используется для ввода паролей.\n  [ширина] = Ширина окна в пикселях, может быть выражением. Если опущена, будет равна 375.\n  [высота] = Высота окна в пикселях, может быть выражением. Если опущена, будет равна 189.\n  [x] и [y] = Координаты окна от верхнего левого угла (0,0). Могут быть отрицательными. Если параметр опущен - окно будет выравнено по середине. Например если X опущен, а Y равен 0, окно будет находиться вверху в центре экрана.\n  [имя шрифта] = Пока не реализовано (оставьте пустым).\n  [тайм-аут] = Таймаут в секундах, может содержать десятичную точку. Если больше 2147483 (24,8 дней), то будет установлен в 2147483. По истечению времени окно будет закрыто, а %.консоль.результат% установлен как -1. При этом то что пользователь успел ввести будет помещено в <вывод>.\n  [текст по-умолчанию] = Текст поля ввода по умолчанию, появляющийся вместе с окном. Пользователь может его стереть или изменить.
RSHELL_COMMAND_DOCUMENTATION_INPUTBOX_TEXT1_PREFIX=Дополнение:
RSHELL_COMMAND_DOCUMENTATION_INPUTBOX_TEXT2=Диалоговое окно содержит поле ввода и две кнопки: Ок и Отмена;\n  Пользователь может изменять размеры окна, перетаскивая границы;\n  Если пользователь нажал Отмена, то <вывод> будет пустой, а %.консоль.результат% установлен как 0. Если нажата клавиша Ок- %.консоль.результат% содержит 1.
RSHELL_COMMAND_DOCUMENTATION_INPUTBOX_EXAMPLE=ввод.окно 'телефон' 'Номер телефона' 'Введите Ваш номер телефона' '' '' '' '' '' '' '' '+7'\n  ввод.окно 'пароль' 'Ввод пароля' 'Введите Ваш пароль (он будет скрыт)' '1' '640' '480' '' '' '' '' ''\n  если '%.консоль.результат%' == '0' то вывод Кнопка ОТМЕНА была нажата.\n  если '%.консоль.результат%' == '1' то вывод Вы указали...``nНомер телефона: %телефон%`nПароль: %пароль%

// Команда "КОДИРОВАТЬ.BASE64".
RSHELL_COMMAND_DOCUMENTATION_ENC_BASE64_SYNTAX=кодировать.base64 '<вывод данных (имя переменной)>' '<ввод данных (имя переменной)>' '<размер данных в байтах>'
RSHELL_COMMAND_DOCUMENTATION_ENC_BASE64_DESCRIPTION=Кодирует данные в Base64.
RSHELL_COMMAND_DOCUMENTATION_ENC_BASE64_EXAMPLE=кодировать.base64 'формат_base64' 'данные' '%размер%'

// Команда "ФАЙЛ.ЗАПИСАТЬ.БИНАР".
RSHELL_COMMAND_DOCUMENTATION_FILE_WRITE_RAW_SYNTAX=файл.записать.бинар '<ввод бинарных данных (имя переменной)>' '<размер в байтах>' '<путь к файлу>'
RSHELL_COMMAND_DOCUMENTATION_FILE_WRITE_RAW_EXAMPLE=файл.записать.бинар 'бинарные_данные' '%размер%' 'test.txt'
RSHELL_COMMAND_DOCUMENTATION_FILE_WRITE_RAW_DESCRIPTION=Записывает в файл содержимое переменной в бинарном режиме.
RSHELL_COMMAND_DOCUMENTATION_FILE_WRITE_RAW_TEXT1=Не удалось открыть файл.

// Команда "ФАЙЛ.ПРОЧИТАТЬ.БИНАР".
RSHELL_COMMAND_DOCUMENTATION_FILE_READ_RAW_SYNTAX=файл.прочитать.бинар '<вывод бинарных данных (имя переменной)>' '<вывод размера в байтах (имя переменной)>' '<путь к файлу>'
RSHELL_COMMAND_DOCUMENTATION_FILE_READ_RAW_EXAMPLE=файл.прочитать.бинар 'бинарные_данные' 'размер' 'test.txt'
RSHELL_COMMAND_DOCUMENTATION_FILE_READ_RAW_DESCRIPTION=Читает файл в бинарном режиме и записывает его содержимое в переменную.
RSHELL_COMMAND_DOCUMENTATION_FILE_READ_RAW_TEXT1=Не удалось открыть файл.

// Команда "КОРЗИНА.ОЧИСТИТЬ".
RSHELL_COMMAND_DOCUMENTAITON_RECYCLE_EMPTY_SYNTAX=корзина.очистить [буква диска]
RSHELL_COMMAND_DOCUMENTATION_RECYCLE_EMPTY_DESCRIPTION=Очищает Корзину.
RSHELL_COMMAND_DOCUMENTATION_RECYCLE_EMPTY_PARAMETER_PREFIX=Параметр [буква диска]
RSHELL_COMMAND_DOCUMENTATION_RECYCLE_EMPTY_PARAMETER=Буква диска, например: C:\. Если параметр опущен, Корзина очищается для всех дисков.
RSHELL_COMMAND_DOCUMENTATION_RECYCLE_EMPTY_NOTE=Эта команда требует, чтобы был установлен Internet Explorer 4 или более поздний.
RSHELL_COMMAND_DOCUMENTATION_RECYCLE_EMPTY_EXAMPLE=корзина.очистить C:\

// Команда "КОРЗИНА.ПЕРЕМЕСТИТЬ".
RSHELL_COMMAND_DOCUMENTATION_RECYCLE_SYNTAX=корзина.переместить <путь к файлу>
RSHELL_COMMAND_DOCUMENTATION_RECYCLE_DESCRIPTION=Отправляет файл или папку в Корзину, если это возможно.
RSHELL_COMMAND_DOCUMENTATION_RECYCLE_NOTE=Чтобы отправить в Корзину папку, укажите её имя без обратной косой черты на конце.
RSHELL_COMMAND_DOCUMENTATION_RECYCLE_EXAMPLE=корзина.переместить test.txt

// Команда "ФАЙЛ.КОДИРОВКА".
RSHELL_COMMAND_DOCUMENTATION_FILE_ENCODING_SYNTAX=файл.кодировка [кодировка]
RSHELL_COMMAND_DOCUMENTATION_FILE_ENCODING_DESCRIPTION=Устанавливает кодировку по умолчанию для команд: файл.прочитать, файл.прочитать.строка, файл.создать, а также для внутренних функций Renux Shell.
RSHELL_COMMAND_DOCUMENTATION_FILE_ENCODING_PARAMETER_PREFIX=Параметр [кодировка]:
RSHELL_COMMAND_DOCUMENTATION_FILE_ENCODING_PARAMETER=Если одно из следующих условий будет опущено, по умолчанию будет установлена кодировка ANSI:\n  UTF-8: Unicode UTF-8, эквивалентный CP65001.\n  UTF-8-RAW: Аналогично выше, но при создании нового файла не записывается порядок байтов.\n  UTF-16: Unicode UTF-16 с прямым порядком байтов, эквивалентно CP1200.\n  UTF-16-RAW: Аналогично выше, но при создании нового файла не записывается порядок байтов.\n  CPnnn: Код страницы с нумеровкой типа nnn. См. Идентификаторы кодовой страницы.
RSHELL_COMMAND_DOCUMENTATION_FILE_ENCODING_EXAMPLE=файл.кодировка UTF-8

// Команда "ВЫВОДФ".
RSHELL_COMMAND_DOCUMENTATION_FILE_OUTPUT_SYNTAX=выводф <путь к файлу>
RSHELL_COMMAND_DOCUMENTATION_FILE_OUTPUT_DESCRIPTION=Выводит содержимое файла в консоль.
RSHELL_COMMAND_DOCUMENTATION_FILE_OUTPUT_EXAMPLE=выводф test.txt

// Команда "ПРОЦЕСС.ИСКАТЬ".
RSHELL_COMMAND_DOCUMENTATION_PROCESS_FIND_SYNTAX=процесс.искать '<имя массива для вывода>' '<полное/часть имени процесса>'
RSHELL_COMMAND_DOCUMENTATION_PROCESS_FIND_DESCRIPTION=Записывает в массив список процессов с их идентификаторами.
RSHELL_COMMAND_DOCUMENTATION_PROCESS_FIND_PARAMETER_PREFIX=Параметр <имя/часть имени процесса>:
RSHELL_COMMAND_DOCUMENTATION_PROCESS_FIND_PARAMETER=Укажите "." для записи всех процессов.
RSHELL_COMMAND_DOCUMENTATION_PROCESS_FIND_EXAMPLE=процесс.искать 'список_процессов' '.'
RSHELL_COMMAND_DOCUMENTATION_PROCESS_FIND_ARR_PROCNAME=_имя
RSHELL_COMMAND_DOCUMENTATION_PROCESS_FIND_ARR_ID=_ид

// Команда "ВЫВОДК".
RSHELL_COMMAND_DOCUMENTATION_KEYBOARD_INPUT_SYNTAX=вводк '<вывод>' '[опции]' '[конечные клавиши]'
RSHELL_COMMAND_DOCUMENTATION_KEYBOARD_INPUT_DESCRIPTION=Ждёт, пока пользователь напечатает строку.
RSHELL_COMMAND_DOCUMENTATION_KEYBOARD_INPUT_ARGUMENTS_PREFIX=Аргументы:
RSHELL_COMMAND_DOCUMENTATION_KEYBOARD_INPUT_ARGUMENTS=вывод = имя переменной для вывода\n  опции = см. ниже\n  конечные клавиши = см. ниже
RSHELL_COMMAND_DOCUMENTATION_KEYBOARD_INPUT_OPTIONS_PREFIX=Опции (может быть пустым или содержать какие-то из следующих букв (в любом порядке, с пробелами или без):
RSHELL_COMMAND_DOCUMENTATION_KEYBOARD_INPUT_OPTIONS=Все буквы на английской раскладке.\n  \n  B - Backspace игнорируется. По умолчанию нажатие Backspace удаляет последний введённый символ с конца строки. Замечание: если вводимый текст видим (например, в редакторе) и были использованы клавиши-стрелки или другое средство для перемещения по тексту, Backspace всё равно удалит последний символ текста, а не тот, что позади каретки (текстового курсора).\n  I: Игнорировать ввод, генерируемый скриптами Renux Shell. Однако, ввод через команду НАПЕЧАТАТЬБ игнорируется всегда, независимо от данной настройки.\n  L: Ограничение длины (например, L5). Максимальная разрешённая длина вводимой строки. Когда текст достигнет указанной длины, команда ВВОДК завершится. Если данный параметр не задан, ограничение по длине составляет 16383 символов, что также является абсолютным максимумом.\n  T: Таймаут (например, T3). Через указанное число секунд команда ВВОДК завершится. Если ВВОДК завершается по таймауту, в "<вывод>" будет текст, который пользователь успел ввести. Можно задавать числом с плавающей точкой, например, 2.5.\n  V: Видимость текста. По умолчанию ввод пользователя блокируется (прячется от системы). Используйте эту опцию, если хотите, чтобы ввод посылался в активное окно.
RSHELL_COMMAND_DOCUMENTATION_KEYBOARD_INPUT_ENDKEYS_PREFIX=Конечные клавиши:
RSHELL_COMMAND_DOCUMENTATION_KEYBOARD_INPUT_ENDKEYS=Может быть пустым или содержать список клавиш, при нажатии на любую из которых работа ВВОДК должна быть завершена (сами эти клавиши не попадут в "<вывод>").\n  В списке "<конечные клавиши>" используется тот же формат, что и для команды НАПЕЧАТАТЬ. Например, при указании {Enter}.{Esc} ВВОДК будет завершаться по нажатию клавиш ENTER, точка (.) или ESCAPE. Чтобы сами фигурные скобки завершали ВВОДК, их нужно задать как {{} и/или {}}.\n  Чтобы использовать Control, Alt или Shift в качестве завершающих, указывайте конкретно левую и/или правую клавишу из пары. Например, {LControl}{RControl}, но не {Control}
RSHELL_COMMAND_DOCUMENTATION_KEYBOARD_INPUT_EXAMPLE=// Изменяет слово "КУ" на "Здравствуйте"\n  цикл вводк 'текст' 'V' '{Space}{Enter}'`;пер текст вниз`;если '%текст%' == 'ку' то напечататьб {BackSpace 3}Здравствуйте,%.консоль.пробел%

// Команда "СПИСОК".
RSHELL_COMMAND_DOCUMENTATION_CMDLIST_SYNTAX=список
RSHELL_COMMAND_DOCUMENTATION_CMDLIST_DESCRIPTION=Выводит список всех команд программы в консоль.

// Команда "ФАЙЛ.ПОЛУЧИТЬ."
RSHELL_COMMAND_DOCUMENTATION_FILE_GET_SYNTAX=файл.получить '<имя массива для вывода>' '<полный путь к файлу>'
RSHELL_COMMAND_DOCUMENTATION_FILE_GET_DESCRIPTION=Записывает в массив свойства файла (обычно для .EXE, .DLL файлов).
RSHELL_COMMAND_DOCUMENTATION_FILE_GET_ARRAY_WRITE_PREFIX=Записывает в массив следующие ключи:
RSHELL_COMMAND_DOCUMENTATION_FILE_GET_ARRAY_WRITE=CompanyName, FileDescription, FileVersion, InternalName, LegalCopyright, OriginalFileName, ProductName, ProductVersion.
RSHELL_COMMAND_DOCUMENTATION_FILE_GET_EXAMPLE=файл.получить 'информация' 'C:\test.exe'

// Команда "ФАЙЛ.ИСКАТЬ".
RSHELL_COMMAND_DOCUMENTATION_FILE_SEARCH_SYNTAX=файл.искать '<название массива для вывода>' '<шаблон файла>' '[режим]'
RSHELL_COMMAND_DOCUMENTATION_FILE_SEARCH_DESCRIPTION=Производит поиск по хранилищу с целью поиска файлов/папок по указанному шаблону.
RSHELL_COMMAND_DOCUMENTATION_FILE_SEARCH_FILE_PATTERN_PREFIX=Шаблон файла:
RSHELL_COMMAND_DOCUMENTATION_FILE_SEARCH_FILE_PATTERN=Имя отдельного файла или папки или шаблон подстановки, например C:\Temp\*.Tmp.\n  Предполагается, что <шаблон файла> находится в %.консоль.рпапка%, если не указан абсолютный путь.
RSHELL_COMMAND_DOCUMENTATION_FILE_SEARCH_MODES_PREFIX=Режимы:
RSHELL_COMMAND_DOCUMENTATION_FILE_SEARCH_MODES=Если пусто или опущено, включаются только файлы, а подкsаталоги не рекурсивны. В противном случае укажите одну или несколько из следующих букв:\n  Д = включать директории.\n  Ф = включать файлы. Если Д и Ф опущены, файлы включаются, но не папки.\n  Р = рекурсия в подкаталоги (подпапки). Если Р не указан, файлы и папки во вложенных папках не включаются.
RSHELL_COMMAND_DOCUMENTATION_FILE_SEARCH_EXAMPLE=файл.искать 'файлы' '*.lnk' 'ФДР'
RSHELL_COMMAND_INTERNAL_FILE_SEARCH_TEXT1=Д
RSHELL_COMMAND_INTERNAL_FILE_SEARCH_TEXT2=Ф
RSHELL_COMMAND_INTERNAL_FILE_SEARCH_TEXT3=Р
RSHELL_COMMAND_INTERNAL_FILE_SEARCH_TEXT4=имя
RSHELL_COMMAND_INTERNAL_FILE_SEARCH_TEXT5=путь
RSHELL_COMMAND_INTERNAL_FILE_SEARCH_TEXT6=Произошла ошибка при выполнении команды.
RSHELL_COMMAND_INTERNAL_FILE_SEARCH_TEXT7=имя
RSHELL_COMMAND_INTERNAL_FILE_SEARCH_TEXT8=путь

// Команда "ОКРУЖЕНИЕ.УСТАНОВИТЬ".
RSHELL_COMMAND_DOCUMENTATION_ENV_SET_SYNTAX=окружение.установить '<имя используемой переменной окружения, например "COMSPEC" или "PATH".>' '<Значение, присваиваемое переменной окружения.>'
RSHELL_COMMAND_DOCUMENTATION_ENV_SET_DESCRIPTION=Задаёт значение переменной окружения.
RSHELL_COMMAND_DOCUMENTATION_ENV_SET_EXAMPLE=окружение.установить 'Renux' 'Текст'

// Команда "ОКРУЖЕНИЕ.ПОЛУЧИТЬ".
RSHELL_COMMAND_DOCUMENTATION_ENV_GET_SYNTAX=окружение.получить '<имя переменной, куда будет помещено полученое значение>' '<Имя внешней переменной, значение которой хотим получить>'
RSHELL_COMMAND_DOCUMENTATION_ENV_GET_DESCRIPTION=Получает значение переменной окружения.
RSHELL_COMMAND_DOCUMENTATION_ENV_GET_EXAMPLE=окружение.получить 'path' 'PATH'

// Команда "ОКРУЖЕНИЕ.ОБНОВИТЬ".
RSHELL_COMMAND_DOCUMENTATION_ENV_UPDATE_SYNTAX=окружение.обновить
RSHELL_COMMAND_DOCUMENTATION_ENV_UPDATE_DESCRIPTION=Уведомляет операционную систему и все текущие приложения о том, что переменные среды изменились.

// Команда "СОБРАТЬ".
RSHELL_COMMAND_DOCUMENTATION_COMPILE_FIRST_PRE_SYNTAX_PREFIX=1-й
RSHELL_COMMAND_DOCUMENTATION_COMPILE_SYNTAX1=собрать
RSHELL_COMMAND_DOCUMENTATION_COMPILE_SECOND_PRE_SYNTAX_PREFIX=2-й
RSHELL_COMMAND_DOCUMENTATION_COMPILE_SYNTAX2=собрать '<путь к пакетному файлу>' '[путь к иконке]' '[параметры запуска]' '[путь для сохранения файла]'
RSHELL_COMMAND_DOCUMENTATION_COMPILE_DESCRIPTION=Конвертирует пакетный файл Renux Shell в исполняемый файл (*.exe).
RSHELL_COMMAND_DOCUMENTATION_COMPILE_PARAMETER_COMPILE_PREFIX=Параметр запуска /COMPILE:
RSHELL_COMMAND_DOCUMENTATION_COMPILE_PARAMETER_COMPILE=Вы можете собрать пакетный файл вызвав командную строку и введя в ней:\n  <путь к Renux Shell> /compile "<путь к пакетному файлу>" "[путь к иконке]" "[параметры запуска]" "[путь для сохранения файла]" "[подключаться к консоли? (0-нет, 1-да)]"\n  \n  - Пример:\n  rshell.exe /compile script.rs icon.ico "" "compiled_script.exe" 1
RSHELL_COMMAND_DOCUMENTATION_COMPILE_NOTE=Если Вы не укажете путь к иконке, то будет использоваться иконка Renux Shell.\n  Если Вы не укажете путь для сохранения файла, то Renux Shell откроет диалоговое окно для выбора папки и имени файла, куда сохранится собранный пакетный файл Renux Shell.
RSHELL_COMMAND_INTERNAL_COMPILE_TEXT1=Добро пожаловать в мастер сборки пакетных файлов Renux Shell.
RSHELL_COMMAND_INTERNAL_COMPILE_TEXT2=Укажите полный путь до пакетного файла (*.rs):
RSHELL_COMMAND_INTERNAL_COMPILE_TEXT3=Укажите полный путь до иконки (*.ico):
RSHELL_COMMAND_INTERNAL_COMPILE_TEXT4=Будет использоваться иконка программы.
RSHELL_COMMAND_INTERNAL_COMPILE_TEXT5=Укажите с какими стартовыми параметрами будет запускаться программа (например, /hide /debug и т.п.):
RSHELL_COMMAND_INTERNAL_COMPILE_TEXT6=Вы не указали путь к пакетному файлу.
RSHELL_COMMAND_INTERNAL_COMPILE_TEXT7=Файл по заданному пути (1-й параметр) не найден.
RSHELL_COMMAND_INTERNAL_COMPILE_TEXT8_PREFIX=Распаковка
RSHELL_COMMAND_INTERNAL_COMPILE_TEXT9=Не удалось распаковать
RSHELL_COMMAND_INTERNAL_COMPILE_TEXT10=Попробуйте повысить права программы и попробовать снова.
RSHELL_COMMAND_INTERNAL_COMPILE_TEXT_IN_WORD=в
RSHELL_COMMAND_INTERNAL_COMPILE_TEXT11=Очистка временных файлов...
RSHELL_COMMAND_INTERNAL_COMPILE_TEXT12=Оптимизация пакетного файла...
RSHELL_COMMAND_INTERNAL_COMPILE_TEXT13=Пакетный файл пуст.
RSHELL_COMMAND_INTERNAL_COMPILE_TEXT14=Оптимизировано %1 строк сценария.
RSHELL_COMMAND_INTERNAL_COMPILE_TEXT15=Сохранение оптимизированного пакетного файла...
RSHELL_COMMAND_INTERNAL_COMPILE_TEXT16=Не удалось сохранить оптимизированный пакетный файл.
RSHELL_COMMAND_INTERNAL_COMPILE_TEXT17=Копирование интерпретатора в папку программы...
RSHELL_COMMAND_INTERNAL_COMPILE_TEXT18_PREFIX=Не удалось скопировать
RSHELL_COMMAND_INTERNAL_COMPILE_TEXT19=Копирование Renux Shell в папку программы...
RSHELL_COMMAND_INTERNAL_COMPILE_TEXT20=Копирование иконки...
RSHELL_COMMMND_INTERNAL_COMPILE_TEXT21=Генерация кода для исполняемого файла...
RSHELL_COMMAND_INTERNAL_COMPILE_TEXT22=Не удалось создать файл executable.tmp в %1!
RSHELL_COMMAND_INTERNAL_COMPILE_TEXT23=Компиляция исполняемого файла...
RSHELL_COMMAND_INTERNAL_COMPILE_TEXT24=Не удалось скомпилировать исходный файл. Ошибка была отображена.
RSHELL_COMMAND_INTERNAL_COMPILE_TEXT25=Укажите, куда сохранить файл
RSHELL_COMMAND_INTERNAL_COMPILE_TEXT26=Копирование исполняемого файла в %1...
RSHELL_COMMAND_INTERNAL_COMPILE_TEXT27=Не удалось скопировать исполняемый файл в %1!
RSHELL_COMMAND_INTERNAL_COMPILE_TEXT28=Попробуйте повысить права программы и попробовать снова.
RSHELL_COMMAND_INTERNAL_COMPILE_TEXT29=Компиляция завершена без ошибок.

// Локализация в собранном .EXE файле (для перехода на новую строку следует использовать `n, вместо \n).
RSHELL_COMMAND_SUPERINTERNAL_COMPILE_TEXT1=Не удалось распаковать файл script.rs.`nПопробуйте повысить права и повторить попытку.
RSHELL_COMMAND_SUPERINTERNAL_COMPILE_TEXT2_PREFIX=Не удалось запустить исполняемый файл rshell.exe. Причина:

// Команда "ЗАПРОС".
RSHELL_COMMAND_DOCUMENTATION_REQUEST_SYNTAX=запрос '<метод>' '<параметр #1>' '<параметр #2>' '[параметр #3]'
RSHELL_COMMAND_DOCUMENTATION_REQUEST_DESCRIPTION=Вызывается объект WinHttpRequest, подробнее см.: https://docs.microsoft.com/en-us/windows/win32/winhttp/winhttprequest
RSHELL_COMMAND_DOCUMENTATION_REQUEST_METHODS_PREFIX=Методы:
RSHELL_COMMAND_DOCUMENTATION_REQUEST_METHODS=открыть (open) - Открывает HTTP-соединение с HTTP-ресурсом.\n  отправить (send) - Отправляет HTTP-запрос на сервер HTTP.\n  устХедер (SetRequestHeader) - Добавляет, изменяет или удаляет заголовок HTTP-запроса.\n  таймаут (SetTimeouts) - Указывает в миллисекундах отдельные компоненты времени ожидания операции отправки и получения.\n  ждатьОтвет (waitForResponse) - Указывает время ожидания для завершения асинхронного метода отправки (в секундах) с необязательным значением времени ожидания.
RSHELL_COMMAND_DOCUMENTATION_REQUEST_NOTE=Во втором параметре метода "отправить" указывается имя объекта без "%" (если загружаются данные формы).
RSHELL_COMMAND_DOCUMENTATION_REQUEST_TEXT1_PREFIX=Пример отправки скриншота на сервер ВКонтакте:
RSHELL_COMMAND_DOCUMENTATION_REQUEST_TEXT1=скриншот C:\temp.png\n  создатьДанныеФормы 'photo' 'C:\temp.png' 'PostData' 'ContentType'\n  ини.прочитать 'токен_вк' '%.консоль.папка%\rshell_config.ini' 'vk' 'token'\n  вкапи 'джсон' 'photos.getMessagesUploadServer&version=5.130'\n  джсон 'джсон_сервер' 'джсон' 'response.upload_url'\n  запрос 'открыть' 'POST' '%джсон_сервер%' '1'\n  запрос 'устХедер' 'Content-Type' '%ContentType%' ''\n  запрос 'отправить' 'PostData' '' ''\n  запрос 'ждатьОтвет' '' '' ''\n  пер джсон_инфо = %.консоль.результат%\n  джсон 'сервер' 'джсон_инфо' 'server'\n  джсон 'фото' 'джсон_инфо' 'photo'\n  джсон 'хеш' 'джсон_инфо' 'hash'\n  пер фото заменить '\"' '"' '1'\n  вкапи 'джсон' 'photos.saveMessagesPhoto&server=%сервер%&photo=%фото%&hash=%хеш%&v=5.103'\n  джсон 'owner_id' 'джсон' 'response[0].owner_id'\n  джсон 'id' 'джсон' 'response[0].id'\n  ранд 'рандом' '1000' '9999'\n  вкапи 'джсон' 'messages.send&random_id=%рандом%&peer_id=%owner_id%&attachment=photo%owner_id%_%id%'\n  вывод Фотография в личных сообщениях.
RSHELL_COMMAND_INTERNAL_REQUEST_WORD_OPEN=открыть
RSHELL_COMMAND_INTERNAL_REQUEST_WORD_SEND=отправить
RSHELL_COMMAND_INTERNAL_REQUEST_TEXT1=В запросе используется объект.
RSHELL_COMMAND_INTERNAL_REQUEST_WORD_SETREQUESTHEADER=устхедер
RSHELL_COMMAND_INTERNAL_REQUEST_WORD_TIMEOUT=таймаут
RSHELL_COMMAND_INTERNAL_REQUEST_WORD_WAITRESPONSE=ждатьответ
RSHELL_COMMAND_INTERNAL_REQUEST_TEXT2=Метод не распознан.

// Команда "РАНД".
RSHELL_COMMAND_DOCUMENTATION_RANDOM_SYNTAX=ранд '<имя переменной, куда запишется результат>' '<минимальное число>' '<максимальное число>'
RSHELL_COMMAND_DOCUMENTATION_RANDOM_DESCRIPTION=Генерирует случайное число и записывает его в переменную.
RSHELL_COMMAND_DOCUMENTATION_RANDOM_EXAMPLE=ранд 'число' '1' '100'\n  вывод Случайное число: %число%.

// Команда "СОЗДАТЬДАННЫЕФОРМЫ".
RSHELL_COMMAND_DOCUMENTATION_CREATEFORMDATA_SYNTAX=создатьДанныеФормы '<тип файла>' '<путь к файлу>' '<вывод #1>''<вывод #2>'
RSHELL_COMMAND_DOCUMENTATION_CREATEFORMDATA_DESCRIPTION=Создает из файла объект, который можно отправить на сервер, командой "ЗАПРОС".
RSHELL_COMMAND_DOCUMENTATION_CREATEFORMDATA_PARAMETERS=Тип файла:\n    "application" - Внутренний формат прикладной программы\n    "audio" - Аудио\n    "image" - Изображение\n    "message" - Сообщение\n    "model" - Для 3D-моделей\n    "multipart" - Email\n    "text" - Текст\n    "video" - Видео\n  \n  Путь к файлу:\n    Указывается путь к файлу, который нужно получить.\n  \n  Вывод #1:\n    Имя переменной, в которую запишется информация: PostData.\n\n  Вывод #2:\n    Имя переменной, в которую запишется информация: Content-Type.
RSHELL_COMMAND_DOCUMENTATION_CREATEFORMDATA_EXAMPLE=создатьДанныеФормы 'photo' 'C:\photo.png' 'PostData' 'ContentType'

// Команда "ЯРКОСТЬ".
RSHELL_COMMAND_DOCUMENTATION_BRIGHTNESS_SYNTAX=яркость <[+/-]число>
RSHELL_COMMAND_DOCUMENTATION_BRIGHTNESS_DESCRIPTION=Изменяет яркость экрана.
RSHELL_COMMAND_DOCUMENTATION_BRIGHTNESS_NOTE=Рекомендуется использовать "-" или "+" перед значением для максимального быстродействия.
RSHELL_COMMAND_DOCUMENTATION_BRIGHTNESS_EXAMPLE=// Устанавливает текущую яркость на 10\n  яркость 10\n  \n  // Добавляет к текущей яркости +10\n  яркость +10\n  \n  // Убавляет с текущей яркости -10\n  яркость -10

// Команда "СКРИНШОТ".
RSHELL_COMMAND_DOCUMENTATION_SCREENSHOT_SYNTAX=скриншот <имя файла>
RSHELL_COMMAND_DOCUMENTATION_SCREENSHOT_DESCRIPTION=Сохраняет снимок экрана в файл.
RSHELL_COMMAND_DOCUMENTATION_SCREENSHOT_EXAMPLE=скриншот screenshot.png

// Команда "РЕЕСТР.УДАЛИТЬ".
RSHELL_COMMAND_DOCUMENTATION_REG_DELETE_SYNTAX=реестр.удалить '<имя корневого раздела>' '<имя подраздела>' '[имя параметра для удаления]'
RSHELL_COMMAND_DOCUMENTATION_REG_DELETE_DESCRIPTION=Удаляет раздел или параметр реестра.
RSHELL_COMMAND_DOCUMENTATION_REG_DELETE_PARAMETERS=имя корневого раздела = Возможные значения: HKEY_LOCAL_MACHINE (или HKLM), HKEY_USERS (или HKU), HKEY_CURRENT_USER (или HKCU), HKEY_CLASSES_ROOT (или HKCR), HKEY_CURRENT_CONFIG (или HKCC). Для доступа к удалённому реестру укажите вначале имя компьютера с двоеточием на конце, как в этом примере: \\workstation01:HKEY_LOCAL_MACHINE\n  имя подраздела = (например, Software\SomeApplication).\n  имя параметра для удаления = Если опущено, будет удалён весь раздел, указанный в SubKey. Чтобы удалить параметр, который отображается в редакторе реестра как параметр "(По умолчанию)".
RSHELL_COMMAND_DOCUMENTATION_REG_DELETE_NOTE=Удаление из реестра потенциально опасно - пожалуйста, будьте осторожны!
RSHELL_COMMAND_DOCUMENTATION_REG_DELETE_EXAMPLE=реестр.удалить 'HKEY_LOCAL_MACHINE' 'Software\SomeApplication' 'TestValue'

// Команда "РЕЕСТР.ПРОЧИТАТЬ".
RSHELL_COMMAND_DOCUMENTATION_REG_READ_SYNTAX=реестр.прочитать '<вывод переменной>' '<имя корневого размера>' '<имя подраздела>' '[имя параметра]'
RSHELL_COMMAND_DOCUMENTATION_REG_READ_DESCRIPTION=Читает параметр из реестра.
RSHELL_COMMAND_DOCUMENTATION_REG_READ_PARAMETERS=вывод переменной = Если значение не может быть считано, переменная будет пустой и .КОНСОЛЬ.РЕЗУЛЬТАТ будет установлен в 1.\n  имя корневого раздела = Возможные значения: HKEY_LOCAL_MACHINE (или HKLM), HKEY_USERS (или HKU), HKEY_CURRENT_USER (или HKCU), HKEY_CLASSES_ROOT (или HKCR), HKEY_CURRENT_CONFIG (или HKCC). Для доступа к удалённому реестру укажите вначале имя компьютера с двоеточием на конце, как в этом примере: \\workstation01:HKEY_LOCAL_MACHINE\n  Имя подраздела = (например, Software\SomeApplication).\n  Имя параметра = (чьё значение нужно прочитать). Если опущен или пустой, будет считан параметр, который в редакторе реестра отображается под именем "(По умолчанию)". Если ему не присвоено никакого значения, выходная переменная будет пустой и .КОНСОЛЬ.РЕЗУЛЬТАТ равен 1.
RSHELL_COMMAND_DOCUMENTATION_REG_READ_NOTES=В настоящее время поддерживаются только следующие типы параметров: REG_SZ, REG_EXPAND_SZ, REG_MULTI_SZ, REG_DWORD, REG_BINARY.\n  Параметры REG_DWORD всегда выражаются в виде положительных десятичных чисел.\n  Из параметров типа REG_BINARY может быть считано не более 64 Кб данных, остальные не имеют таких ограничений.\n  При чтении REG_BINARY результатом будет строка шестнадцатеричных цифр. Например: REG_BINARY со значением 01,a9,ff,77 будет считан как 01A9FF77.\n  При чтении REG_MULTI_SZ все его компоненты оканчиваются переводом строки (`n). Если компонентов нет, выходная переменная будет пустой.
RSHELL_COMMAND_DOCUMENTATION_REG_READ_EXAMPLE=реестр.прочитать 'PATH' 'HKCU' 'Environment' 'PATH'

// Команда "РЕЕСТР.ЗАПИСАТЬ".
RSHELL_COMMAND_DOCUMENTATION_REG_WRITE_SYNTAX=реестр.записать '<тип записываемого параметра>' '<имя корневого раздела>' '<имя подраздела>' '<имя параметра реестра>' '[значение для записываемого параметра]'
RSHELL_COMMAND_DOCUMENTATION_REG_WRITE_DESCRIPTION=Записывает параметр в реестр.
RSHELL_COMMAND_DOCUMENTATION_REG_WRITE_PARAMETERS=Тип записываемого параметра = Возможные значения: REG_SZ, REG_EXPAND_SZ, REG_MULTI_SZ, REG_DWORD, REG_BINARY.\n  Имя корневого раздела = Возможные значения: HKEY_LOCAL_MACHINE (или HKLM), HKEY_USERS (или HKU), HKEY_CURRENT_USER (или HKCU), HKEY_CLASSES_ROOT (или HKCR), HKEY_CURRENT_CONFIG (или HKCC). Для доступа к удалённому реестру укажите вначале имя компьютера с двоеточием на конце, как в этом примере: \\workstation01:HKEY_LOCAL_MACHINE\n  Имя подраздела = (например, Software\SomeApplication). Если раздел не существует, он будет создан (вместе со своими родительскими разделами, если необходимо). Если SubKey оставлен пустым, запись произойдёт прямо в корневой раздел (хотя некоторые операционные системы могут отказаться писать в HKEY_CURRENT_USER).\n  Имя параметра реестра = (который будет записан). Если опущен или пустой, будет записан параметр, который в редакторе реестра отображается под именем "(По умолчанию)".\n  Значение для записываемого параметра = Если опущено, считается пустой строкой либо нулём, в зависимости от типа параметра.
RSHELL_COMMAND_DOCUMENTATION_REG_WRITE_NOTES=Значение параметров типа REG_DWORD должно лежать между -2147483648 и 4294967295 (0xFFFFFFFF).\n  Параметры REG_BINARY и REG_MULTI_SZ допускают запись до 64 Кб данных, остальные не имеют ограничений. Когда это ограничение действует, данные, находящиеся после 64 Кб, не будут записаны. Другими словами, только первые 64 Кб очень длинной строки будут сохранены в реестре.\n  При записи параметра REG_BINARY используйте строку из шестнадцатеричных цифр. Например, значение REG_BINARY 01,a9,ff,77 может быть записано при указании в команде строки 01A9FF77.\n  При записи REG_MULTI_SZ вы должны отделять каждый компонент от следующего символом перевода строки (``n). Последний компонент также можно (но необязательно) завершить переводом строки. Пустые компоненты не допускаются. Другими словами, не указывайте два перевода строки подряд (``n``n), поскольку результатом будет запись в реестр значения более короткого, чем ожидалось.
RSHELL_COMMAND_DOCUMENTATION_REG_WRITE_EXAMPLE=реестр.записать 'REG_SZ' 'HKEY_LOCAL_MACHINE' 'SOFTWARE\TestKey' 'MyValueName' 'Test Value'\n  реестр.записать 'REG_BINARY' 'HKEY_CURRENT_USER' 'Software\TEST_APP' 'TEST_NAME' '01A9FF77'\n  реестр.записать 'REG_MULTI_SZ' 'HKEY_CURRENT_USER' 'Software\TEST_APP' 'TEST_NAME' 'Строка1``nСтрока2'

// Команда "ПРОИГРАТЬ".
RSHELL_COMMAND_DOCUMENTATION_SOUND_PLAY_SYNTAX=проиграть '<имя файла>' '[ждать? (1-да/0-нет)]>
RSHELL_COMMAND_DOCUMENTATION_SOUND_PLAY_DESCRIPTION=Проигрывает аудио- и видеофайлы, или файлы другого поддерживаемого формата.
RSHELL_COMMAND_DOCUMENTATION_SOUND_PLAY_PARAMETERS=имя файла = Если не задан полный путь, файл ищется в рабочей папке.\n  Для воспроизведения стандартных системных звуков задайте этот параметр в виде звёздочки с числом, как показано ниже. Заметьте, что параметр "ждать" в этом случае не действует.\n  *-1 Простой звук. Если звуковая карта недоступна, этот звук будет воспроизведён через динамик системного блока.\n  *16 Стоп/Ошибка\n  *32 Вопрос\n  *48 Восклицание\n  *64 Звёздочка (информация)\n  Какие файлы будут в этих случаях проигрываться, определяется настройкой системной звуковой схемы в диалоге "Звуки и аудиоустройства".\n  ждать? = Если опущен, выполнение следующих команд из текущего потока скрипта продолжается, в то время как файл проигрывается. Чтобы заставить поток ждать окончания проигрывания файла, присвойте параметру значение 1.\n  Известные ограничения: если параметр ЖДАТЬ опущен, операционная система иногда может воспринимать проигрываемый файл как занятый до тех пор, пока скрипт не будет закрыт или пока не будет проигран другой файл (даже несуществующий).
RSHELL_COMMAND_DOCUMENTATION_SOUND_PLAY_NOTES=Все операционные системы Windows могут проигрывать wav-файлы. Однако файлы других форматов (mp3, avi и т.д.) могут требовать установки соответствующих кодеков. Если скрипт, воспроизводящий файл, начнёт проигрывать другой файл, воспроизведение первого файла будет остановлено. На некоторых системах файлы определённых форматов могут останавливаться, даже если проигрывание второго файла начато не тем же самым, а другим скриптом. Чтобы остановить проигрывание файла, используйте команду ПРОИГРАТЬ с несуществующим файлом в качестве параметра. Если работа скрипта завершается, воспроизведение любого файла, запущенное этим скриптом, останавливается.
RSHELL_COMMAND_DOCUMENTATION_SOUND_PLAY_EXAMPLE=проиграть 'tada.wav' '1'

// Команда "ЗВУКИНФО".
RSHELL_COMMAND_DOCUMENTATION_SOUND_GET_SYNTAX=звукинфо '<переменная для вывода>' '[тип компонента]' '[вид настройки]' '[номер устройства]'
RSHELL_COMMAND_DOCUMENTATION_SOUND_GET_DESCRIPTION=Считывает текущие настройки звукового устройства (микшера). Окно с этими настройками открывается, например, при двойном щелчке по динамику в трее.
RSHELL_COMMAND_DOCUMENTATION_SOUND_GET_PARAMETERS=переменная для вывода = Имя выходной переменной. В зависимости от вида считываемой настройки возвращаемое в переменную значение может быть числом (с плавающей точкой) в диапазоне от 0 до 100 (включительно), либо словом ON или OFF (для настроек ONOFF, MUTE, MONO, LOUDNESS, STEREOENH, BASSBOOST). Если считать настройку не удалось, переменная будет пустой.\n  тип компонента = Тип компонента (соотносится с одним из регуляторов в окне настроек микшера). Если опущен или пустой, принимает значение MASTER (общий регулятор громкости, который доступен также при одиночном щелчке по динамику в трее). Допустимые значения: MASTER (то же, что SPEAKERS), DIGITAL, LINE, MICROPHONE, SYNTH, CD, TELEPHONE, PCSPEAKER, WAVE, AUX, ANALOG. Если микшер не содержит указанного компонента, это будет отражено сообщением в переменной .консоль.результат (см. список ниже). Компонент, обозначаемый в микшере как Auxiliary (дополнительный), иногда может быть доступен как ANALOG, а не как AUX. Если микшер имеет более одного экземпляра какого-то компонента, то обычно первый содержит настройки воспроизведения, а второй - настройки записи. Для доступа ко второму и следующим экземплярам добавляйте двоеточие и номер к имени компонента. Например, Analog:2.\n  вид настройки = Если опущен или пустой, принимает значение VOLUME (громкость). Допустимые значения: VOLUME (или VOL), ONOFF, MUTE, MONO, LOUDNESS, STEREOENH, BASSBOOST, PAN, QSOUNDPAN, BASS, TREBLE, EQUALIZER. Если компонент не поддерживает указанный вид настройки, это будет отражено сообщением в переменной .консоль.результат (см. список ниже).\n  номер устройства = Если опущен, принимает значение 1, что обычно соответствует системному устройству по умолчанию для записи и воспроизведения. Для доступа к другим устройствам указывайте номер больше единицы.
RSHELL_COMMAND_DOCUMENTATION_SOUND_GET_TEXT1_PREFIX=Возможный текст ошибок:
RSHELL_COMMAND_DOCUMENTATION_SOUND_GET_TEXT2=- Неверный вид настройки или тип компонента\n  - Не могу открыть указанный микшер\n  - Микшер не поддерживает указанный компонент\n  - Количество компонентов данного типа в микшере меньше, чем указанный номер\n  - Компонент не поддерживает указанную настройку\n  - Не могу считать текущую настройку
RSHELL_COMMAND_DOCUMENTATION_SOUND_GET_NOTE=Для изменения настроек используйте команду ГРОМКОСТЬ.
RSHELL_COMMAND_DOCUMENTATION_SOUND_GET_EXAMPLE=звукинфо 'громкость' '' '' ''\n  вывод Общий регулятор громкости сейчас на уровне %громкость% процентов.\n  \n  звукинфо 'master_mute' '' 'mute' ''\n  вывод Выключатель общего регулятора громкости сейчас в положении %master_mute%.
RSHELL_COMMAND_INTERNAL_SOUND_GET_TEXT1=Неверный вид настройки или тип компонента
RSHELL_COMMAND_INTERNAL_SOUND_GET_TEXT2=Не могу открыть указанный микшер
RSHELL_COMMAND_INTERNAL_SOUND_GET_TEXT3=Микшер не поддерживает указанный компонент
RSHELL_COMMAND_INTERNAL_SOUND_GET_TEXT4=Количество компонентов данного типа в микшере меньше, чем указанный номер
RSHELL_COMMAND_INTERNAL_SOUND_GET_TEXT5=Компонент не поддерживает указанную настройку
RSHELL_COMMAND_INTERNAL_SOUND_GET_TEXT6=Не могу считать текущую настройку
RSHELL_COMMAND_INTERNAL_SOUND_GET_TEXT7=Не могу изменить настройку

// Команда "ГУДОК".
RSHELL_COMMAND_DOCUMENTATION_SOUND_BEEP_SYNTAX=гудок '<частота в герцах>' '<длительность в мс>
RSHELL_COMMAND_DOCUMENTATION_SOUND_BEEP_DESCRIPTION=Издаёт звук через динамик системного блока.
RSHELL_COMMAND_DOCUMENTATION_SOUND_BEEP_NOTE=Программа ждёт окончания звука, чтобы продолжить свою работу. Кроме того отзывчивость (responsiveness) системы в целом может на это время снижаться.
RSHELL_COMMAND_DOCUMENTATION_SOUND_BEEP_EXAMPLE=гудок '750' '500'

// Команда "МОНИТОР".
RSHELL_COMMAND_DOCUMENTATION_DISPLAY_SYNTAX=монитор <действие>
RSHELL_COMMAND_DOCUMENTATION_DISPLAY_DESCRIPTION=Выключает/включает монитор.
RSHELL_COMMAND_DOCUMENTATION_DISPLAY_ACTIONS_PREFIX=Действия:
RSHELL_COMMAND_DOCUMENTATION_DISPLAY_ACTIONS=включить - включает монитор\n  выключить - выключает монитор\n  малая - режим малой мощности монитора
RSHELL_COMMAND_DOCUMENTATION_DISPLAY_EXAMPLE=монитор выключить\n  ждать.время 5000\n  монитор включить
RSHELL_COMMAND_INTERNAL_DISPLAY_ACTION_OFF_WORD=выключить
RSHELL_COMMAND_INTERNAL_DISPLAY_ACTION_ON_WORD=включить
RSHELL_COMMAND_INTERNAL_DISPLAY_ACTION_ECO_WORD=малая
RSHELL_COMMAND_INTERNAL_DISPLAY_ACTION_TEXT1=Действие не распознано.

// Команда "УВЕДОМЛЕНИЕ".
RSHELL_COMMAND_DOCUMENTATION_TRAYTIP_SYNTAX=уведомление '<заголовок>' '<текст>' '<тайм-аут>' '<опции>'
RSHELL_COMMAND_DOCUMENTATION_TRAYTIP_DESCRIPTION=Создает всплывающее окно с сообщением рядом со значком в трее. В Windows 10 вместо этого может отображаться всплывающее уведомление.
RSHELL_COMMAND_DOCUMENTATION_TRAYTIP_OPTIONS_PREFIX=Опции:
RSHELL_COMMAND_DOCUMENTATION_TRAYTIP_OPTIONS=Параметр может быть комбинацией (суммой) нуля или более следующих значений:\n  - Значок информации - 1,\n  - Значок предупреждения - 2,\n  - Значок ошибки - 3,\n  - не воспроизводить звук уведомления - 16,\n  - использовать большую версию значка - 32.\n  \n  По умолчанию параметр равен 0. Значок не отображается, если отсутствует заголовок (это не относится к всплывающим уведомлениям Windows 10).
RSHELL_COMMAND_DOCUMENTATION_TRAYTIP_NOTE=Windows 10 по умолчанию заменяет все всплывающие окна всплывающими уведомлениями (это можно переопределить с помощью групповой политики). Многократный вызов "УВЕДОМЛЕНИЕ" обычно приводит к тому, что несколько уведомлений помещаются в «очередь», а не каждое уведомление заменяет последнее. Чтобы скрыть уведомление, временное удаление иконки в трее может быть эффективным.\n  \n  "УВЕДОМЛЕНИЕ" не действует, если следующее значение REG_DWORD существует и имеет значение 0:\n    HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced >> EnableBalloonTips
RSHELL_COMMAND_DOCUMENTATION_TRAYTIP_EXAMPLE=уведомление 'Привет' 'Это сообщение показывается 5 секунд' '5' '1'

// Команда "СООБЩЕНИЕ".
RSHELL_COMMAND_DOCUMENTATION_MSGBOX_SYNTAX=сообщение '<опции>' '<заголовок>' '<текст>' '[тайм-аут]'
RSHELL_COMMAND_DOCUMENTATION_MSGBOX_DESCRIPTION=Отображает на экране диалоговое окно с кнопками (например: да/нет).
RSHELL_COMMAND_DOCUMENTATION_MSGBOX_TEXT1=Опции = Устанавливает тип окна (обычное, информационное, ошибка, предупреждение), а также комбинации кнопок. Если опущен, то по умолчанию принимает значение 0 (обычное окно с кнопкой Ок).\nЗаголовок = Заголовок окна сообщение. По умолчанию содержит имя файла Renux.\nТекст = Если все параметры опущены, СООБЩЕНИЕ отображает текст "Нажмите ОК для продолжения". В противном случае, этот параметр отвечает за текст, который будет отображаться в диалоговом окне. Можно использовать также управляющие последовательности, такие как ``n -перевод строки, ``t -табуляция и т.д. Если текст длинный его рекомендуется разбить на несколько строк для улучшения читаемости.\nТайм-аут = (необязательный параметр): Задает время в секундах, до автоматического закрытия диалогового окна. После истечения времени окно будет закрыто, а переменная .сообщение.результат примет значение "Тайм-Аут". Может быть дробным числом, не превышающим 2147483 (24,8 дней).
RSHELL_COMMAND_DOCUMENTATION_MSGBOX_OPTIONS_PREFIX=Опции:
RSHELL_COMMAND_DOCUMENTATION_MSGBOX_OPTIONS=Можно использовать одновременно несколько опций, для этого их значение нужно сложить,\n  Например: Нам нужны кнопки Прервать/Повторить/Игнорировать и информационное окно, тогда складываем 2+64, параметр ОПЦИИ в этом случае должен содержать 66!\n\n  Функция - Числовое значение:\n  ОК - 0\n  ОК/Отмена - 1\n  Прервать/Повторить/Пропустить - 2\n  Да/Нет/Отмена - 3\n  Да/Нет - 4\n  Повторить/Отмена - 5\n  Отмена/Повторить/Продолжить - 6\n  \n  Тип окна: Ошибка - 16\n  Тип окна: Вопрос - 32\n  Тип окна: Предупреждение - 48\n  Тип окна: Информация - 64\n  \n  Максимальное значение: 100.
RSHELL_COMMAND_DOCUMENTATION_MSGBOX_ADDITION_PREFIX=Дополнение:
RSHELL_COMMAND_DOCUMENTATION_MSGBOX_ADDITION=Для определения кнопки, выбраной пользователем используется переменная .СООБЩЕНИЕ.ОТВЕТ:\n  \n  сообщение '4' 'Выбор' 'Вы хотите продолжить? (Нажмите Да или Нет)'\n  если '%сообщение.ответ%' == 'Да' то вывод Вы нажали "Да"\n  если '%сообщение.ответ%' == 'Нет' то вывод Вы нажали "Нет"
RSHELL_COMMAND_DOCUMENTATION_MSGBOX_ADVICE_PREFIX=Совет:
RSHELL_COMMAND_DOCUMENTATION_MSGBOX_ADVICE=Нажатие Ctrl+C во время показа Msgbox (команда СООБЩЕНИЕ) копирует его текст в буфер обмена. Это относится ко всем диалоговым окнам, в том числе не созданых Renux Shell.
RSHELL_COMMAND_DOCUMENTATION_MSGBOX_CLOSE_BUTTON_PREFIX=Кнопка закрыть:
RSHELL_COMMAND_DOCUMENTATION_MSGBOX_CLOSE_BUTTON=Если окно имеет только один вариант выбора (ОК), кнопка X будет работать идентично кнопке ОК.\n  Если окно имеет вид Да/Нет, то кнопка X будет соответствовать отрицательному выбору.
RSHELL_COMMAND_DOCUMENTATION_MSGBOX_EXAMPLE=сообщение '0' '' 'Привет' ''\n\n  сообщение '4' '' 'Хотите продолжить?' ''\n  если '%.сообщение.ответ%' == 'Нет' то выход\n\n  сообщение '4' '' 'Этот пример с использованием таймаута 5 секунд.  Продолжить?' '5'\n  если '%.сообщение.ответ%' == 'Тайм-аут' то сообщение '' '' 'Вы не отреагировали в течении 5 секунд' '';выход\n  если '%.сообщение.ответ%' == 'Нет' то выход\n  сообщение '0' '' 'Это конец =(' ''
RSHELL_COMMAND_INTERNAL_MSGBOX_RESPONSE_VARNAME=.сообщение.ответ
RSHELL_COMMAND_INTERNAL_MSGBOX_RESPONSE_WORD_YES=Да
RSHELL_COMMAND_INTERNAL_MSGBOX_RESPONSE_WORD_NO=Нет
RSHELL_COMMAND_INTERNAL_MSGBOX_RESPONSE_WORD_OK=ОК
RSHELL_COMMAND_INTERNAL_MSGBOX_RESPONSE_WORD_CANCEL=Отмена
RSHELL_COMMAND_INTERNAL_MSGBOX_RESPONSE_WORD_ABORT=Прервать
RSHELL_COMMAND_INTERNAL_MSGBOX_RESPONSE_WORD_IGNORE=Игнорировать
RSHELL_COMMAND_INTERNAL_MSGBOX_RESPONSE_WORD_RETRY=Повторить
RSHELL_COMMAND_INTERNAL_MSGBOX_RESPONSE_WORD_TIMEOUT=Тайм-аут

// Команда "ГРОМКОСТЬ".
RSHELL_COMMAND_DOCUMENTATION_SOUND_SET_SYNTAX=громкость '<новый параметр>' '[тип компонента]' '[вид настройки]' '[номер устройства]'
RSHELL_COMMAND_DOCUMENTATION_SOUND_SET_DESCRIPTION=Изменяет настройки звукового устройства (микшера). Окно с этими настройками открывается, например, при двойном щелчке по динамику в трее.
RSHELL_COMMAND_DOCUMENTATION_SOUND_SET_TEXT1=Новый параметр = Новая настройка. Число в диапазоне от -100 до 100 включительно (может быть числом с плавающей точкой). Если число указано со знаком (плюс или минус), значение настройки будет увеличено или уменьшено на указанную величину. Иначе текущее значение настройки будет заменено указанной величиной.Для настроек с двумя возможными значениями, а именно ONOFF, MUTE, MONO, LOUDNESS, STEREOENH, BASSBOOST, любое положительное число будет включать настройку, а ноль - выключать. Однако любое число с явно указанным знаком (плюс или минус) будет просто переключать настройку в противоположное состояние.\nТип компонента = Если опущен или пустой, принимает значение MASTER (общий регулятор громкости, который доступен также при одиночном щелчке по динамику в трее). Допустимые значения: MASTER (то же, что SPEAKERS), DIGITAL, LINE, MICROPHONE, SYNTH, CD, TELEPHONE, PCSPEAKER, WAVE, AUX, ANALOG. Если микшер не содержит указанного компонента, это будет отражено сообщением в переменной .КОНСОЛЬ.РЕЗУЛЬТАТ (см. справку). Компонент, обозначаемый в микшере как Auxiliary (дополнительный), иногда может быть доступен как ANALOG, а не как AUX. Если микшер имеет более одного экземпляра какого-то компонента, то обычно первый содержит настройки воспроизведения, а второй - настройки записи. Для доступа ко второму и следующим экземплярам добавляйте двоеточие и номер к имени компонента. Например, Analog:2.\nВид настройки = Если опущен или пустой, принимает значение VOLUME (громкость). Допустимые значения: VOLUME (или VOL), ONOFF, MUTE, MONO, LOUDNESS, STEREOENH, BASSBOOST, PAN, QSOUNDPAN, BASS, TREBLE, EQUALIZER. Если компонент не поддерживает указанный вид настройки, это будет отражено сообщением в переменной .КОНСОЛЬ.РЕЗУЛЬТАТ (см. справку).\nНомер устройства = Может быть выражением. Номер устройства. Если опущен, принимает значение 1, что обычно соответствует системному устройству по умолчанию для записи и воспроизведения. Для доступа к другим устройствам указывайте номер больше единицы.
RSHELL_COMMAND_DOCUMENTATION_SOUND_SET_TEXT2=Возможный текст ошибок:\n  - Неверный вид настройки или тип компонента\n  - Не могу открыть указанный микшер\n  - Микшер не поддерживает указанный компонент\n  - Количество компонентов данного типа в микшере меньше, чем указанный номер\n  - Компонент не поддерживает указанную настройку\n  - Не могу считать текущую настройку\n  - Не могу изменить настройку
RSHELL_COMMAND_DOCUMENTATION_SOUND_SET_EXAMPLES=// Общий регулятор громкости на середину.\n  громкость '50' '' '' ''\n\n  // Увеличить общую громкость на 10%.\n  громкость '+10' '' '' ''\n  \n  // Уменьшить общую громкость на 10%\n  громкость '-10' '' '' ''\n  \n  // Отключить микрофон\n  громкость '1' 'Microphone' 'mute' ''\n  \n  // Переключить выключатель общей громкости (в противоположное состояние).\n  громкость '+1' '' 'mute' ''\n  \n  // Поднять нижние частоты на 20%.\n  громкость '+20' 'Master' 'bass' ''\n  если '%.консоль.результат%' != '1' то вывод Настройка нижних частот не поддерживается общим регулятором громкости.
RSHELL_COMMAND_INTERNAL_SOUND_SET_TEXT1=Неверный вид настройки или тип компонента
RSHELL_COMMAND_INTERNAL_SOUND_SET_TEXT2=Не могу открыть указанный микшер
RSHELL_COMMAND_INTERNAL_SOUND_SET_TEXT3=Микшер не поддерживает указанный компонент
RSHELL_COMMAND_INTERNAL_SOUND_SET_TEXT4=Количество компонентов данного типа в микшере меньше, чем указанный номер
RSHELL_COMMAND_INTERNAL_SOUND_SET_TEXT5=Компонент не поддерживает указанную настройку
RSHELL_COMMAND_INTERNAL_SOUND_SET_TEXT6=Не могу получить текущую настройку
RSHELL_COMMAND_INTERNAL_SOUND_SET_TEXT7=Не могу изменить настройку

// Команда "ФАЙЛ.РАЗМЕР".
RSHELL_COMMAND_DOCUMENTATION_FILE_SIZE_SYNTAX=файл.размер '<переменная, в которую запишется результат>' '<путь к файлу>'
RSHELL_COMMAND_DOCUMENTATION_FILE_SIZE_DESCRIPTION=Определяет размер файла в байтах.
RSHELL_COMMAND_DOCUMENTATION_FILE_SIZE_EXAMPLE=файл.размер 'размер' 'C:\test.txt'

// Команда "ФАЙЛ.КОПИРОВАТЬ.ПАПКА".
RSHELL_COMMAND_DOCUMENTATION_FILE_COPY_DIR_SYNTAX=файл.копировать.папка '<путь к папке, которая будет копироваться>' '<путь к папке, куда будет скопировано>' '<копировать с перезаписью?(flag=1/0)>'
RSHELL_COMMAND_DOCUMENTATION_FILE_COPY_DIR_DESCRIPTION=Копирует папку вместе с содержимым в другое место.
RSHELL_COMMAND_DOCUMENTATION_FILE_COPY_DIR_EXAMPLE=файл.копировать.папка 'C:\test' 'C:\test2' '1'

// Команда "ФАЙЛ.КОПИРОВАТЬ".
RSHELL_COMMAND_DOCUMENTATION_FILE_COPY_SYNTAX=файл.копировать '<путь к файлу, который будет копироваться>' '<путь к файлу, куда будет скопировано>' '<копировать с перезаписью?(flag=1/0)>'
RSHELL_COMMAND_DOCUMENTATION_FILE_COPY_DESCRIPTION=Копирует содержимое файла в другой файл.
RSHELL_COMMAND_DOCUMENTATION_FILE_COPY_EXAMPLE=файл.копировать 'C:\test.txt' 'C:\test2.txt' '1'

// Команда "ФАЙЛ.УДАЛИТЬ.ПАПКА".
RSHELL_COMMAND_DOCUMENTATION_FILE_DELETE_DIR_SYNTAX=файл.удалить.папка <путь к файлу>
RSHELL_COMMAND_DOCUMENTATION_FILE_DELETE_DIR_DESCRIPTION=Удаляет папку по указанному Вами пути.
RSHELL_COMMAND_DOCUMENTATION_FILE_DELETE_DIR_EXAMPLE=файл.удалить.папка C:\test
RSHELL_COMMAND_DOCUMENTATION_FILE_DELETE_DIR_TEXT1=Не удалось удалить папку по пути: %1

// Команда "ФАЙЛ.УДАЛИТЬ".
RSHELL_COMMAND_DOCUMENTATION_FILE_DELETE_SYNTAX=файл.удалить <путь к файлу>
RSHELL_COMMAND_DOCUMENTATION_FILE_DELETE_DESCRIPTION=Удалит файл по указанному Вами пути.
RSHELL_COMMAND_DOCUMENTATION_FILE_DELETE_EXAMPLE=файл.удалить C:\text.txt
RSHELL_COMMAND_DOCUMENTATION_FILE_DELETE_TEXT1=Не удалось удалить файл по пути: %1

// Команда "ФАЙЛ.СОЗДАТЬ.ПАПКА".
RSHELL_COMMAND_DOCUMENTATION_FILE_CREATE_DIR_SYNTAX=файл.создать.папка <путь к папке>
RSHELL_COMMAND_DOCUMENTATION_FILE_CREATE_DIR_DESCRIPTION=Создаст папку по указанному Вами пути.
RSHELL_COMMAND_DOCUMENTATION_FILE_CREATE_DIR_EXAMPLE=файл.создать.папка C:\test

// Команда "ФАЙЛ.СОЗДАТЬ".
RSHELL_COMMAND_DOCUMENTATION_FILE_APPEND_SYNTAX=файл.создать '<путь к файлу>' '<текст>'
RSHELL_COMMAND_DOCUMENTATION_FILE_APPEND_DESCRIPTION=Renux создаст/дополнит файл текстом по указанному Вами пути.
RSHELL_COMMAND_DOCUMENTATION_FILE_APPEND_EXAMPLE=файл.создать 'C:\text.txt' 'Привет, Мир!'

// Команда "ФАЙЛ.ПРОЧИТАТЬ.СТРОКА".
RSHELL_COMMAND_DOCUMENTATION_FILE_READ_LINE_SYNTAX=файл.прочитать.строка '<название переменной для вывода >' '<путь к файлу>' '<номер строки (от 1)>
RSHELL_COMMAND_DOCUMENTATION_FILE_READ_LINE_DESCRIPTION=Читает определённую строку в файле и помещает текст в переменную.
RSHELL_COMMAND_DOCUMENTATION_FILE_READ_LINE_EXAMPLE=файл.прочитать.строка 'текст_четвертой_строки' 'С:\test.txt' '4'

// Команда "ФАЙЛ.ПРОЧИТАТЬ".
RSHELL_COMMAND_DOCUMENTATION_FILE_READ_SYNTAX=файл.прочитать '<название переменной>' '<путь к файлу>'
RSHELL_COMMAND_DOCUMENTATION_FILE_READ_DESCRIPTION=Renux запишет содержание файла в переменную.
RSHELL_COMMAND_DOCUMENTATION_FILE_READ_EXAMPLE=файл.прочитать 'текст_файла' 'C:\text.txt'

// Команда "ФАЙЛ.ПОЛУЧИТЬ.ЯРЛЫК".
RSHELL_COMMAND_DOCUMENTATION_FILE_GET_LABEL_SYNTAX=файл.получить.ярлык '<имя массива>' '<путь к файлу>'
RSHELL_COMMAND_DOCUMENTATION_FILE_GET_LABEL_DESCRIPTION=Возвращает свойства ярлыка в виде массива.
RSHELL_COMMAND_DOCUMENTATION_FILE_GET_LABEL_EXAMPLE=файл.получить.ярлык 'ярлык' 'test.lnk'
RSHELL_COMMAND_DOCUMENTATION_FILE_GET_LABEL_TEXT1=Запишет в массив информацию о ярлыке:\n[файл] = Имя переменной, куда будет помещён путь к объекту ярлыка (без передаваемых ему аргументов). Например: C:\WINDOWS\system32\notepad.exe\n[папка] = Имя переменной, куда будет помещён путь к рабочей папке ярлыка. Например: C:\Мои документы.\n[параметры] = Имя переменной для сохранения параметров, передаваемых объекту ярлыка.\n[описание] = Имя переменной для сохранения комментария к ярлыку.\n[значок] = Имя переменной для сохранения имени файла, в котором находится значок ярлыка.\n[номер_значка] = Имя переменной для сохранения номера значка ярлыка, если в файле больше одного значка. Чаще всего это номер 1, что означает первый значок.\n[старт_сост] = Имя переменной, куда помещается состояние окна при запуске ярлыка, может обозначаться следующими цифрами: 1 - нормальное окно; 3 - развёрнутое; 7 - свёрнутое.
RSHELL_COMMAND_INTERNAL_FILE_GET_LABEL_FILE_WORD=файл
RSHELL_COMMAND_INTERNAL_FILE_GET_LABEL_DIR_WORD=папка
RSHELL_COMMAND_INTERNAL_FILE_GET_LABEL_PARAMETERS_WORD=параметры
RSHELL_COMMAND_INTERNAL_FILE_GET_LABEL_DESCRIPTION_WORD=описание
RSHELL_COMMAND_INTERNAL_FILE_GET_LABEL_ICON_WORD=значок
RSHELL_COMMAND_INTERNAL_FILE_GET_LABEL_NUMBER_OF_ICON_WORD=номер_значка
RSHELL_COMMAND_INTERNAL_FILE_GET_LABEL_START_STATUS_WORD=старт_сост

// Команда "ФАЙЛ.ПЕРЕМЕСТИТЬ.ПАПКА".
RSHELL_COMMAND_DOCUMENTATION_FILE_MOVE_DIR_SYNTAX=файл.переместить.папка '<путь к папке>' '<новый путь к папке>' '<flag (действия в примечаниях)>'
RSHELL_COMMAND_DOCUMENTATION_FILE_MOVE_DIR_DESCRIPTION=Перемещает/переименовывает папку вместе со всеми её подпапками и - файлами.
RSHELL_COMMAND_DOCUMENTATION_FILE_MOVE_DIR_EXAMPLE=файл.переместить.папка 'C:\test' 'C:\Program Files\test' '0'
RSHELL_COMMAND_DOCUMENTATION_FILE_MOVE_DIR_TEXT1=Примечание: в третьем аргументе укаказывается 0/1/2/R.\n0 = не переписывать существующие файлы. Операция закончится неудачей, если <второй аргумент>s уже существует как файл или папка.\n1 = переписывать существующие файлы. Однако никакие файлы или папки в <первый аргумент>, которые не совпадают по имени с указанными в <второй аргумент>, удалены не будут. Известное ограничение: если <второй аргумент> уже существует как папка и находится в том же разделе диска, что и <первый аргумент>, <первый аргумент> будет помещён внутрь <второй аргумент> вместо того, чтобы переписать его. Чтобы избежать этого, используйте следующую опцию.\n2 = то же, что 1, но упомянутое ограничение отсутствует (рекомендуется вместо 1).\nR = переименовать папку вместо перемещения её. Хотя переименование в норме даёт тот же эффект, что и перемещение, это может быть полезно в случаях, когда вы хотите "всё или ничего", т.е. вас не устраивает частичный успех операции, когда <первый аргумент> или один из его файлов блокирован (используется). Хотя этот метод не может переместить <первый аргумент> в другой раздел, он может переместить его в любую другую папку в его собственном разделе. Операция закончится неудачей, если <второй аргумент> уже существует как файл или папка.

// Команда "ФАЙЛ.ПЕРЕМЕСТИТЬ".
RSHELL_COMMAND_DOCUMENTATION_FILE_MOVE_SYNTAX=файл.переместить '<путь к файлу>' '<новый путь к файлу>' '<копировать с перезаписью?(flag=1/0)>'
RSHELL_COMMAND_DOCUMENTATION_FILE_MOVE_DESCRIPTION=Перемещает файл по указанному Вами пути.
RSHELL_COMMAND_DOCUMENTATION_FILE_MOVE_EXAMPLE=файл.переместить 'C:\test.txt' 'C:\new_test_name.txt' '1'

// Команда "ФАЙЛ.ВРЕМЯ.ПОЛУЧИТЬ".
RSHELL_COMMAND_DOCUMENTATION_FILE_TIME_GET_SYNTAX=файл.время.получить '<переменная, куда запишется результат> '<путь к файлу>' '<С/И/Д>'
RSHELL_COMMAND_DOCUMENTATION_FILE_TIME_GET_EXAMPLE=файл.время.получить 'время' 'C:\test.txt' 'С'
RSHELL_COMMAND_DOCUMENTATION_FILE_TIME_GET_TEXT1=В третьем параметре указывается только одна буква. Она отвечает за то, какое время нужно получить:\nС - время создания файла.\nИ - время последнего изменения файла.\nД - время последнего доступа к файлу.\n\nВозвращаемая строка будет содержать время в формате "YYYYMMDDHH24MISS".\n\nЭлементы формата временив:\nYYYY = Год, 4 цифры\nMM = Месяц, 2 цифры (01-12)\nDD = День месяца, 2 цифры (01-31)\nHH24 = Час в 24-часовом формате, 2 цифры (00-23).\nMI = Минуты, 2 цифры (00-59)\nSS = Секунды, 2 цифры (00-59)
RSHELL_COMMAND_INTERNAL_FILE_TIME_GET_ERRORVALUE=ОШИБКА
RSHELL_COMMAND_INTERNAL_FILE_TIME_GET_CVALUE=С
RSHELL_COMMAND_INTERNAL_FILE_TIME_GET_MVALUE=И
RSHELL_COMMAND_INTERNAL_FILE_TIME_GET_AVALUE=Д

// Команда "ФАЙЛ.ВРЕМЯ.УСТАНОВИТЬ".
RSHELL_COMMAND_DOCUMENTATION_FILE_TIME_SET_SYNTAX=файл.время.установить '[время в формате YYYYMMDDHH24MISS]' '<путь к файлу>'
RSHELL_COMMAND_DOCUMENTATION_FILE_TIME_SET_DESCRIPTION=Изменяет отметку даты и времени файла или папки.
RSHELL_COMMAND_DOCUMENTATION_FILE_TIME_SET_EXAMPLE=файл.время.установить '20210122165500' 'C:\test.txt'
RSHELL_COMMAND_DOCUMENTATION_FILE_TIME_SET_TEXT1=Если первый параметр пустой, он принимает значение текущего времени. Иначе укажите, какое время использовать (формат: YYYYMMDDHH24MISS). Годы до 1601 не поддерживаются.\n\nЭлементы формата времени:\nYYYY = Год, 4 цифры\nMM = Месяц, 2 цифры (01-12)\nDD = День месяца, 2 цифры (01-31)	\nHH24 = Час в 24-часовом формате, 2 цифры (00-23)\nMI = Минуты, 2 цифры (00-59)\nSS = Секунды, 2 цифры (00-59)

// Команда "СКАЧАТЬ".
RSHELL_COMMAND_DOCUMENTATION_DOWNLOAD_SYNTAX=скачать '<прямая ссылка>' '<путь>'
RSHELL_COMMAND_DOCUMENTATION_DOWNLOAD_DESCRIPTION=Скачать файл из Сети Интернет.
RSHELL_COMMAND_DOCUMENTATION_DOWNLOAD_EXAMPLE=скачать 'http://example.com' 'test.html'

// Команда "ПРОГ".
RSHELL_COMMAND_DOCUMENTATION_PROG_SYNTAX=прог
RSHELL_COMMAND_DOCUMENTATION_PROG_DESCRIPTION=Взаимодействует с программами от Streleckiy Development.
RSHELL_COMMAND_INTERNAL_PROG_TEXT1=Получение информации о продуктах...
RSHELL_COMMAND_INTERNAL_PROG_TEXT2=Необходимо установить программу (консоль установить).
RSHELL_COMMAND_INTERNAL_PROG_TEXT3=Не удалось получить список продуктов. Попробуйте позже.
RSHELL_COMMAND_INTERNAL_PROG_TEXT4=Для установки доступно %1 приложений:
RSHELL_COMMAND_INTERNAL_PROG_TEXT5=Укажите номер приложения
RSHELL_COMMAND_INTERNAL_PROG_TEXT6=Нужно указать целое число.
RSHELL_COMMAND_INTERNAL_PROG_TEXT7=Номер приложения выходит за границы списка.
RSHELL_COMMAND_INTERNAL_PROG_TEXT8=Доступные варианты действий:
RSHELL_COMMAND_INTERNAL_PROG_TEXT9=Обновить программу
RSHELL_COMMAND_INTERNAL_PROG_TEXT10=Удалить программу
RSHELL_COMMAND_INTERNAL_PROG_TEXT11=Укажите номер действия
RSHELL_COMMAND_INTERNAL_PROG_TEXT12=Установить программу
RSHELL_COMMAND_INTERNAL_PROG_TEXT13=Укажите номер действия
RSHELL_COMMAND_INTERNAL_PROG_TEXT14=Вы точно желаете удалить программу? [Y/N]
RSHELL_COMMAND_INTERNAL_PROG_TEXT15=Удаление программы %1...
RSHELL_COMMAND_INTERNAL_PROG_TEXT16=Не удалось удалить папку по пути: %1
RSHELL_COMMAND_INTERNAL_PROG_TEXT17=Не удалось получить список файлов продукта. Попробуйте позже.
RSHELL_COMMAND_INTERNAL_PROG_TEXT18=Файлы, которые установит программа:
RSHELL_COMMAND_INTERNAL_PROG_TEXT19=Установка займет %1 байт памяти. Установить? [Y/N]
RSHELL_COMMAND_INTERNAL_PROG_TEXT21=Скачивание файла '%1' (%2 байт)...
RSHELL_COMMAND_INTERNAL_PROG_TEXT22=Размер файла не совпадает с размером файла на сервере. Повторяю попытку скачивания...
RSHELL_COMMAND_INTERNAL_PROG_TEXT23=Создание ярлыка на рабочем столе...
RSHELL_COMMAND_INTERNAL_PROG_TEXT24=Запустить
RSHELL_COMMAND_INTERNAL_PROG_TEXT25=Создание ярлыка в меню Пуск...

// Команда "ИНИ.УДАЛИТЬ".
RSHELL_COMMAND_DOCUMENTATION_INI_DELETE_SYNTAX=ини.удалить '<путь к файлу>' '<секция>' '<ключ>'
RSHELL_COMMAND_DOCUMENTATION_INI_DELETE_DESCRIPTION=Удаляет параметр из INI-файла стандартного формата.
RSHELL_COMMAND_DOCUMENTATION_INI_DELETE_EXAMPLE=ини.удалить 'settings.ini' 'погода' 'город'

// Команда "ИНИ.ПРОЧИТАТЬ".
RSHELL_COMMAND_DOCUMENTATION_INI_READ_SYNTAX=ини.прочитать '<имя переменной, куда запишется значение>' '<путь к файлу>' '<секция>' '<ключ>'
RSHELL_COMMAND_DOCUMENTATION_INI_READ_DESCRIPTION=Читает значение параметра из INI-файла стандартного формата.
RSHELL_COMMAND_DOCUMENTATION_INI_READ_EXAMPLE=ини.прочитать 'погода_город' 'settings.ini' 'погода' 'город'
RSHELL_COMMAND_DOCUMENTATION_INI_READ_CONSOLERESULT=Если команда выполнена с ошибкой, то это будет в записано в переменной, которая указана в первом аргументе.\n  Переменная .КОНСОЛЬ.РЕЗУЛЬТАТ меняет свое значение на "1" (единицу) в любом случае.
RSHELL_COMMAND_DOCUMENTATION_INI_READ_ERRORVALUE=ОШИБКА

// Команда "ИНИ.ЗАПИСАТЬ".
RSHELL_COMMAND_DOCUMENTATION_INI_WRITE_SYNTAX=ини.записать '<значение>' '<путь к файлу>' '<секция>' '<ключ>'
RSHELL_COMMAND_DOCUMENTATION_INI_WRITE_DESCRIPTION=Пишет параметр в INI-файл стандартного формата.
RSHELL_COMMAND_DOCUMENTATION_INI_WRITE_EXAMPLE=ини.записать 'Москва' 'settings.ini' 'погода' 'город'

// Команда "ДИСК.ПОЛУЧИТЬ.СПАМЯТЬ".
RSHELL_COMMAND_DOCUMENTATION_DRIVE_GET_MEMORY_SYNTAX=диск.получить.спамять '<имя переменной для вывода>' '<путь к диску>'
RSHELL_COMMAND_DOCUMENTATION_DRIVE_GET_MEMORY_DESCRIPTION=Определяет объём свободного места на диске, в мегабайтах.
RSHELL_COMMAND_DOCUMENTATION_DRIVE_GET_MEMORY_EXAMPLE=диск.получить.спамять 'свободное_место' 'C:\'

// Команда "ДИСК.ПОЛУЧИТЬ".
RSHELL_COMMAND_DOCUMENTATION_DRIVE_GET_SYNTAX=диск.получить '<переменная для вывода>' '<команда>' '[значение]'
RSHELL_COMMAND_DOCUMENTATION_DRIVE_GET_DESCRIPTION=Предоставляет разного рода информацию о дисках компьютера.
RSHELL_COMMAND_DOCUMENTATION_DRIVE_GET_TEXT1=Команды, 'значения':\nсписок '[тип]' = помещает в переменную для вывода строку из букв, каждая из которых является буквой одного из существующих в системе дисков. Например: ACDEZ. Если параметр [Тип] опущен, перечисляются диски всех типов. Если нужен только какой-то определённый тип, Type можно задать одним из следующих слов: CDROM, REMOVABLE, FIXED, NETWORK, RAMDISK, UNKNOWN.\nемкость '<путь>' = определяет полную ёмкость диска, указанного в [путь] (например, C:\) в мегабайтах.\nфс '<диск>' = определяет файловую систему диска. <Диск> задаётся либо буквой с двоеточием и необязательной обратной косой чертой, либо как имя UNC наподобие \\server1\share1. В <переменная для вывода> будет помещено одно из следующих слов: FAT, FAT32, NTFS, CDFS (обычно означает CD), UDF (обычно означает DVD). <Переменная для вывода> будет пустой и %.консоль.результат% равен 0, если привод не содержит форматированного носителя.\nметка '<диск>' = определяет метку диска. Диск задаётся в параметре <диск> либо буквой с двоеточием и необязательной обратной косой чертой, либо как имя UNC наподобие \\server1\share1.\nтип '<путь>' = определяет тип указанного в <путь> диска, обозначаемый одним из следующих слов: Unknown, Removable, Fixed, Network, CDROM, RAMDisk.\nстатус '<путь>' = определяет статус указанного в <путь> диска, обозначаемый одним из следующих слов: Unknown (может означать неформатированный диск), Ready, NotReady (типично для приводов, не содержащих носителя), Invalid (диск, указанный в <путь>, не существует или является сетевым диском, который в данный момент недоступен).\nстатусЦД '[диск]' = определяет состояние привода CD или DVD. <Диск> задаётся буквой с двоеточием (если пустой, будет использован CD/DVD-привод по умолчанию). Переменная для вывода будет пустой, если состояние не может быть определено. Иначе туда помещается одно из следующих слов:\n\nnot ready - Привод не готов для доступа, возможно потому, что занят операцией записи. Известные ограничения: "not ready" также получается, когда в приводе диск DVD, а не CD.\nopen - Привод не содержит диска или его лоток выдвинут.\nplaying - Привод проигрывает диск.\npaused - Проигрывание аудио или видео приостановлено.\nseeking - Привод занят поиском на диске.\nstopped - Привод содержит CD-диск, но в данный момент не обращается к нему.
RSHELL_COMMAND_DOCUMENTATION_DRIVE_GET_TEXT2_PREFIX=Пример 1:
RSHELL_COMMAND_DOCUMENTATION_DRIVE_GET_EXAMPLE1=диск.получить 'емкость' 'емкость' 'C:\'
RSHELL_COMMAND_DOCUMENTATION_DRIVE_GET_TEXT3_PREFIX=Пример 2:
RSHELL_COMMAND_DOCUMENTATION_DRIVE_GET_EXAMPLE2=диск.получить 'список_дисков' 'список' ''
RSHELL_COMMAND_INTERNAL_DRIVE_GET_TEXT1=список
RSHELL_COMMAND_INTERNAL_DRIVE_GET_TEXT2=емкость
RSHELL_COMMAND_INTERNAL_DRIVE_GET_TEXT3=фс
RSHELL_COMMAND_INTERNAL_DRIVE_GET_TEXT4=метка
RSHELL_COMMAND_INTERNAL_DRIVE_GET_TEXT5=тип
RSHELL_COMMAND_INTERNAL_DRIVE_GET_TEXT6=статус
RSHELL_COMMAND_INTERNAL_DRIVE_GET_TEXT7=статусЦД

// Команда "ДИСК.ПРИВОД".
RSHELL_COMMAND_DOCUMENTATION_DRIVE_SYNTAX=диск.привод
RSHELL_COMMAND_DOCUMENTATION_DRIVE_DESCRIPTION=Выдвигает/втягивает лоток CD- или DVD-привода.

// Команда "ДИР".
RSHELL_COMMAND_DOCUMENTATION_DIR_SYNTAX=дир [шаблон названия файла]
RSHELL_COMMAND_DOCUMENTATION_DIR_DESCRIPTION=Отобразит содержимое текущей директории.
RSHELL_COMMAND_DOCUMENTATION_DIR_TEXT1=Если указан параметр "шаблон названия файла", то будет выполняться поиск по шаблону. Пример команды с использованием по шаблону: дир *.txt
RSHELL_COMMAND_INTERNAL_DIR_TEXT1=Содержание папки %1:
RSHELL_COMMAND_INTERNAL_DIR_TEXT2=Установленный фильтр поиска: %1.
RSHELL_COMMAND_INTERNAL_DIR_TEXT3=ПАПКА
RSHELL_COMMAND_INTERNAL_DIR_TEXT4=СКРИПТ
RSHELL_COMMAND_INTERNAL_DIR_TEXT5=Найдено %1 файлов и %2 папок.

// Команда "СД. / СД.. / СД..."
RSHELL_COMMAND_DOCUMENTATION_CD_DOT_SYNTAX1_PREFIX=Синтаксис 1:
RSHELL_COMMAND_DOCUMENTATION_CD_DOT_SYNTAX2_PREFIX=Синтаксис 2:
RSHELL_COMMAND_DOCUMENTATION_CD_DOT_SYNTAX3_PREFIX=Синтаксис 3:
RSHELL_COMMAND_DOCUMENTATION_CD_DOT_SYNTAX1=сд.
RSHELL_COMMAND_DOCUMENTATION_CD_DOT_SYNTAX2=сд..
RSHELL_COMMAND_DOCUMENTATION_CD_DOT_SYNTAX3=сд...
RSHELL_COMMAND_DOCUMENTATION_CD_DOT_DESCRIPTION=Переход в родительский каталог (на один/два/три уровень вверх).
RSHELL_COMMAND_DOCUMENTATION_CD_DOT_NOTE=СД. - переход на один уровень вверх.\n  СД.. - переход на два уровня вверх.\n  Сд... - переход на три уровня вверх.

// Команда "СД".
RSHELL_COMMAND_DOCUMENTATION_CD_SYNTAX=сд <путь к директории/часть имени директории/имя ярлыка/часть имени ярлыка>
RSHELL_COMMAND_DOCUMENTATION_CD_DESCRIPTION=Смена текущей директории.
RSHELL_COMMAND_DOCUMENTATION_CD_EXAMPLE=сд C:\\n  сд Windows\n  сд System32

// Команда "АТРИБУТЫ.УСТАНОВИТЬ".
RSHELL_COMMAND_DOCUMENTATION_ATTR_SET_SYNTAX=атрибуты.установить '<(+/-)атрибуты (RASHNDOCT)>' '<путь к файлу>'
RSHELL_COMMAND_DOCUMENTATION_ATTR_SET_TEXT1=Изменяет атрибуты файла или папки.\n\nR = READONLY (только чтение)\nA = ARCHIVE (архивный)\nS = SYSTEM (системный)\nH = HIDDEN (скрытый)\nN = NORMAL (нормальный)\nO = OFFLINE (отключен)\nT = TEMPORARY (временный)
RSHELL_COMMAND_DOCUMENTATION_ATTR_SET_EXAMPLE=атрибуты.установить '+A-H' 'C:\test.txt'

// Команда "АТРИБУТЫ.ПОЛУЧИТЬ".
RSHELL_COMMAND_DOCUMENTATION_ATTR_GET_SYNTAX=атрибуты.получить '<переменная, в которую запишется результат>' '<путь к файлу>'
RSHELL_COMMAND_DOCUMENTATION_ATTR_GET_DESCRIPTION=Получает атрибуты файла или папки.
RSHELL_COMMAND_DOCUMENTATION_ATTR_GET_TEXT1=Возвращаемая строка будет содержать какие-то из этих букв: "RASHNDOCT".\nR = READONLY (только чтение)\nA = ARCHIVE (архивный)\nS = SYSTEM (системный)\nH = HIDDEN (скрытый)\nN = NORMAL (нормальный)\nD = DIRECTORY (каталог)\nO = OFFLINE (отключен)\nC = COMPRESSED (сжатый)\nT = TEMPORARY (временный)
RSHELL_COMMAND_DOCUMENTATION_ATTR_GET_EXAMPLE=атрибуты.получить 'атрибуты' 'C:\test.txt'

// Команда "ПОСТ".
RSHELL_COMMAND_DOCUMENTATION_POST_SYNTAX=пост '<переменная, куда запишется ответ>' '<URL>' '<текст запроса>'
RSHELL_COMMAND_DOCUMENTATION_POST_DESCRIPTION=Отправляет POST-запрос на указанный Вами сервер.
RSHELL_COMMAND_DOCUMENTATION_POST_EXAMPLE=пост 'ответ_сервера' 'https://api.telegram.org/botXXXXXXXXXXXXXX/sendMessage' 'text=test_message&chat_id=100'
RSHELL_COMMAND_INTERNAL_POST_TEXT1=Не удалось создать объект: WinHttp.WinHttpRequest.5.1
RSHELL_COMMAND_INTERNAL_POST_TEXT2=Не удалось открыть сессию пост-запроса:
RSHELL_COMMAND_INTERNAL_POST_TEXT3=Не удалось добавить хедер 'User-Agent' для сессии пост-запроса.
RSHELL_COMMAND_INTERNAL_POST_TEXT4=Не удалось добавить хедер 'Content-Type' для сессии пост-запроса.
RSHELL_COMMAND_INTERNAL_POST_TEXT5=Не удалось отправить запрос с дополнением:
RSHELL_COMMAND_INTERNAL_POST_TEXT6=Не получилось дождаться ответа сервера!
RSHELL_COMMAND_INTERNAL_POST_TEXT7=Не удалось получить ответ сервера!

// Команда "ВКАПИ".
RSHELL_COMMAND_DOCUMENTATION_VKAPI_SYNTAX=вкапи '<переменная, куда запишется ответ>' '<текст запроса>'
RSHELL_COMMAND_DOCUMENTATION_VKAPI_DESCRIPTION=Отправить запрос на сервер VK и записать ответ в переменную.
RSHELL_COMMAND_DOCUMENTATION_VKAPI_NOTE=Используйте команду "ВКАПИ." для того, чтобы стереть информацию о токене VK с текущего ПК.
RSHELL_COMMAND_DOCUMENTATION_VKAPI_EXAMPLE=вкапи 'информация' 'users.get'
RSHELL_COMMAND_INTERNAL_VKAPI_TEXT1=Для использования VK API нужна авторизация.
RSHELL_COMMAND_INTERNAL_VKAPI_TEXT2=Как Вы желаете войти в аккаунт ВКонтакте? [1 - через логин/пароль, 2 - по токену, 3 - отмена]
RSHELL_COMMAND_INTERNAL_VKAPI_TEXT3_PREFIX=Укажите номер телефона/логин от страницы:
RSHELL_COMMAND_INTERNAL_VKAPI_TEXT4_PREFIX=Укажите пароль от страницы:
RSHELL_COMMAND_INTERNAL_VKAPI_TEXT5=Не удалось получить ответ сервера.
RSHELL_COMMAND_INTERNAL_VKAPI_TEXT6=Нужен ввод капчи!
RSHELL_COMMAND_INTERNAL_VKAPI_TEXT7=Попробуйте авторизоваться через токен.
RSHELL_COMMAND_INTERNAL_VKAPI_TEXT8=Создание объекта...
RSHELL_COMMAND_INTERNAL_VKAPI_TEXT9=Произошла ошибка при создании объекта. Убедитесь, что у Вас установлен и обновлен Internet Explorer, а также не имеются поврежденные файлы.
RSHELL_COMMAND_INTERNAL_VKAPI_TEXT10=Ожидание загрузки страницы...
RSHELL_COMMAND_INTERNAL_VKAPI_TEXT11=Ожидание действий пользователя...
RSHELL_COMMAND_INTERNAL_VKAPI_TEXT12_PREFIX=Укажите токен от страницы:
RSHELL_COMMAND_INTERNAL_VKAPI_TEXT13=Недействительный токен!
RSHELL_COMMAND_INTERNAL_VKAPI_TEXT14=Авторизоваться не удалось.
RSHELL_COMMAND_INTERNAL_VKAPI_TEXT15=Авторизация успешна.
RSHELL_COMMAND_INTERNAL_VKAPI_TEXT16=Теперь Вы можете использовать VK API в Renux Shell.

// Команда "СЕТЬ.СКАНИРОВАТЬ".
RSHELL_COMMAND_DOCUMENTATION_NETWORK_SCAN_SYNTAX=сеть.сканировать
RSHELL_COMMAND_DOCUMENTATION_NETWORK_SCAN_DESCRIPTION=Отображает текущие ARP записи, опрашивая текущие данные.

// Распространенный текст в команде "ГОЛОС.*".
RSHELL_COMMAND_INTERNAL_VOICESP_COMMON_TEXT1=Создание объекта SAPI.SpVoice...

// Команда "ГОЛОС.СКОРОСТЬ".
RSHELL_COMMAND_DOCUMENTATION_VOICESP_SPEED_SYNTAX=голос.скорость <скорость (целое число в диапазоне от -10 до 10)>
RSHELL_COMMAND_DOCUMENTATION_VOICESP_SPEED_DESCRIPTION=Установит параметр скорости речи для преобразования текста в речь (Text-To-Speech).
RSHELL_COMMAND_DOCUMENTATION_VOICESP_SPEED_TEXT1=По-умолчанию скорость 0.
RSHELL_COMMAND_DOCUMENTATION_VOICESP_SPEED_EXAMPLE=голос.скорость 0

// Команда "ГОЛОС.СКАЗАТЬ".
RSHELL_COMMAND_DOCUMENTATION_VOICESP_SAY_SYNTAX=голос.сказать <текст>
RSHELL_COMMAND_DOCUMENTATION_VOICESP_SAY_DESCRIPTION=Преобразует текст в речь (Text-To-Speech).
RSHELL_COMMAND_DOCUMENTATION_VOICESP_SAY_EXAMPLE=голос.сказать Привет, Мир!

// Команда "ГОЛОС.ГРОМКОСТЬ".
RSHELL_COMMAND_DOCUMENTATION_VOICESP_VOLUME_SYNTAX=голос.громкость <громкость (целое число в диапазоне от 0 до 100)>
RSHELL_COMMAND_DOCUMENTATION_VOICESP_VOLUME_DESCRIPTION=Установит параметр громкости для преобразования текста в речь (Text-To-Speech).
RSHELL_COMMAND_DOCUMENTATION_VOICESP_VOLUME_TEXT1=По-умолчанию громкость 100.
RSHELL_COMMAND_DOCUMENTATION_VOICESP_VOLUME_EXAMPLE=голос.громкость 100

// Команда "#СКАЧИВАТЬ_БЕЗ_СПРОСА" (директива).
RSHELL_DIRECTIVE_DOCUMENTATION_DWASK_SYNTAX=#СКАЧИВАТЬ_БЕЗ_СПРОСА
RSHELL_DIRECTIVE_DOCUMENTATION_DWASK_DESCRIPTION=Получить разрешение от пользователя для скачивания файлов из интернета без спроса (команда "скачать" всегда отображает сколько весит файл и скачать ли его, с этим разрешением Renux Shell сможет скачивать файлы в фоновом режиме).
RSHELL_DIRECTIVE_INTERNAL_DWASK_TEXT1=Renux спрашивает разрешение на скачивание файлов без спроса. [Y/N]

// Команда "ОКНО.СПРЯТАТЬ".
RSHELL_COMMAND_DOCUMENTATION_WIN_HIDE_SYNTAX=окно.спрятать <заголовок/его часть>
RSHELL_COMMAND_DOCUMENTATION_WIN_HIDE_DESCRIPTION=Скроет окно с указанным заголовком.
RSHELL_COMMAND_DOCUMENTATION_WIN_HIDE_EXAMPLE=окно.спрятать Безымянный - Paint

// Команда "ОКНО.СВЕРНУТЬ".
RSHELL_COMMAND_DOCUMENTATION_WIN_MINIMIZE_SYNTAX=окно.свернуть <заголовок/его часть>
RSHELL_COMMAND_DOCUMENTATION_WIN_MINIMIZE_DESCRIPTION=Свернет окно с указанным заголовком.
RSHELL_COMMAND_DOCUMENTATION_WIN_MINIMIZE_EXAMPLE=окно.свернуть Безымянный - Paint

// Команда "ОКНО.РАЗВЕРНУТЬ".
RSHELL_COMMAND_DOCUMENTATION_WIN_MAXIMIZE_SYNTAX=окно.развернуть <заголовок/его часть>
RSHELL_COMMAND_DOCUMENTATION_WIN_MAXIMIZE_DESCRIPTION=Развернет окно с указанным заголовком.
RSHELL_COMMAND_DOCUMENTATION_WIN_MAXIMIZE_EXAMPLE=окно.развернуть Безымянный - Paint

// Команда "ОКНО.ПОКАЗАТЬ".
RSHELL_COMMAND_DOCUMENTATION_WIN_SHOW_SYNTAX=окно.показать <заголовок/его часть>
RSHELL_COMMAND_DOCUMENTATION_WIN_SHOW_DESCRIPTION=Покажет скрытое окно с указанным заголовком.
RSHELL_COMMAND_DOCUMENTATION_WIN_SHOW_EXAMPLE=окно.показать Безымянный - Paint

// Команда "ОКНО.ЗАКРЫТЬ".
RSHELL_COMMAND_DOCUMENTATION_WIN_CLOSE_SYNTAX=окно.закрыть <заголовок/его часть>
RSHELL_COMMAND_DOCUMENTATION_WIN_CLOSE_DESCRIPTION=Закроет окно с указанным Вами заголовком.
RSHELL_COMMAND_DOCUMENTATION_WIN_CLOSE_EXAMPLE=окно.закрыть Безымянный - Paint

// Команда "ОКНО.ЗАГОЛОВОК".
RSHELL_COMMAND_DOCUMENTATION_WIN_TITLE_SYNTAX=окно.заголовок '<заголовок>' '<новый заголовок>'
RSHELL_COMMAND_DOCUMENTATION_WIN_TITLE_DESCRIPTION=Изменяет заголовок окна на указанный Вами.
RSHELL_COMMAND_DOCUMENTATION_WIN_TITLE_EXAMPLE=окно.заголовок 'Безымянный - Paint' 'Просто Paint'

// Команда "ОКНО.ВЕРНУТЬ".
RSHELL_COMMAND_DOCUMENTATION_WIN_RESTORE_SYNTAX=окно.вернуть <заголовок/его часть>
RSHELL_COMMAND_DOCUMENTATION_WIN_RESTORE_DESCRIPTION=Восстанавливает прежние размеры свёрнутого или развёрнутого окна.
RSHELL_COMMAND_DOCUMENTATION_WIN_RESTORE_EXAMPLE=окно.вернуть Безымянный - Paint

// Команда "ОКНО.АКТИВИРОВАТЬ".
RSHELL_COMMAND_DOCUMENTATION_WIN_ACTIVATE_SYNTAX=окно.активировать <заголовок/его часть>
RSHELL_COMMAND_DOCUMENTATION_WIN_ACTIVATE_DESCRIPTION=Активирует окно с указанным заголовком.
RSHELL_COMMAND_DOCUMENTATION_WIN_ACTIVATE_EXAMPLE=окно.активировать Безымянный - Paint

// Команда "ЖДАТЬ.ОКНО.ЗАКРЫТИЕ".
RSHELL_COMMAND_DOCUMENTATION_WIN_WAIT_CLOSE_SYNTAX=ждать.окно.закрытие <заголовок/его часть>
RSHELL_COMMAND_DOCUMENTATION_WIN_WAIT_CLOSE_DESCRIPTION=Ожидает закрытию окна с указанным заголовком.
RSHELL_COMMAND_DOCUMENTATION_WIN_WAIT_CLOSE_EXAMPLE=ждать.окно.закрытие Безымянный - Paint

// Команда "ЖДАТЬ.ОКНО.ДЕАКТИВИРОВАТЬ".
RSHELL_COMMAND_DOCUMENTATION_WIN_WAIT_DEACTIVE_SYNTAX=ждать.окно.деактивировать <заголовок/его часть>
RSHELL_COMMAND_DOCUMENTATION_WIN_WAIT_DEACTIVE_DESCRIPTION=Ожидает деактивацию окна с указанным заголовком.
RSHELL_COMMAND_DOCUMENTATION_WIN_WAIT_DEACTIVE_EXAMPLE=ждать.окно.деактивировать Безымянный - Paint

// Команда "ЖДАТЬ.ОКНО.АКТИВИРОВАТЬ".
RSHELL_COMMAND_DOCUMENTATION_WIN_WAIT_ACTIVE_SYNTAX=ждать.окно.активировать <заголовок/его часть>
RSHELL_COMMAND_DOCUMENTATION_WIN_WAIT_ACTIVE_DESCRIPTION=Ожидает активацию окна с указанным заголовком.
RSHELL_COMMAND_DOCUMENTATION_WIN_WAIT_ACTIVE_EXAMPLE=ждать.окно.активировать Безымянный - Paint

// Команда "ЖДАТЬ.ОКНО".
RSHELL_COMMAND_DOCUMENTATION_WIN_WAIT_SYNTAX=ждать.окно <заголовок/его часть>
RSHELL_COMMAND_DOCUMENTATION_WIN_WAIT_DESCRIPTION=Ожидает создание окна с указанным заголовком.
RSHELL_COMMAND_DOCUMENTATION_WIN_WAIT_EXAMPLE=ждать.окно Безымянный - Paint

// Команда "ЖДАТЬ.НАЖАТИЕ".
RSHELL_COMMAND_DOCUMENTATION_WAIT_KEY_SYNTAX=ждать.нажатие '<имя переменной>' '<клавиша/клавиши>'
RSHELL_COMMAND_DOCUMENTATION_WAIT_KEY_DESCRIPTION=Ждет нажатие заданных какой либо из клавиш/клавиши, прежде чем продолжить.
RSHELL_COMMAND_DOCUMENTATION_WAIT_KEY_NOTE1=После нажатия одной из клавиш, в переменную, указанную в первом аргументе будет записано имя клавиши, которая была нажата.
RSHELL_COMMAND_DOCUMENTATION_WAIT_KEY_NOTE2=Если Вам нужно указать сразу несколько клавиш, то перечисляйте их через запятую. Без пробелов.
RSHELL_COMMAND_DOCUMENTATION_WAIT_KEY_TEXT1_PREFIX=Пример 1 (ожидается нажатие на Y):
RSHELL_COMMAND_DOCUMENTATION_WAIT_KEY_TEXT2_PREFIX=Пример 2 (ожидается нажатие на Y или N):
RSHELL_COMMAND_DOCUMENTATION_WAIT_KEY_TEXT3=ждать.нажатие 'переменная1' 'Y'
RSHELL_COMMAND_DOCUMENTATION_WAIT_KEY_TEXT4=ждать.нажатие 'переменная2' 'Y,N'

// Команда "ЖДАТЬ.ВРЕМЯ".
RSHELL_COMMAND_DOCUMENTATION_WAIT_TIME_SYNTAX=ждать.время <время ожидания в миллисекундах>
RSHELL_COMMAND_DOCUMENTATION_WAIT_TIME_DESCRIPTION=Ждёт заданное количество времени, прежде чем продолжить.
RSHELL_COMMAND_DOCUMENTATION_WAIT_TIME_NOTE=Время ожидания в миллисекундах в диапазоне от 0 до 2147483647 (24 дня).
RSHELL_COMMAND_DOCUMENTATION_WAIT_TIME_EXAMPLE=// Ждет 3 секунды\n  ждать.время 3000

// Команда "ВЫХОД".
RSHELL_COMMAND_DOCUMENTATION_EXIT_SYNTAX=выход [код]
RSHELL_COMMAND_DOCUMENTATION_EXIT_DESCRIPTION=Закрытие процесса Renux Shell (с кодом выхода).
RSHELL_COMMAND_DOCUMENTATION_EXIT_NOTE=Если параметр [код] опущен, то закрывается с нулевым кодом выхода.

// Команда "СТРОКА.ЗАМЕНИТЬ".
RSHELL_COMMAND_DOCUMENTATION_STRING_REPLACE_SYNTAX=строка.заменить '<имя переменной, куда запишется результат>' '<строка (текст)> '<символы, которые нужно заменить>' '<символы, которыми нужно заменить>' '<заменить все? (0-нет/1-да)>'
RSHELL_COMMAND_DOCUMENTATION_STRING_REPLACE_DESCRIPTION=Заменяет вхождения строки поиска на строку замены.
RSHELL_COMMAND_DOCUMENTATION_STRING_REPLACE_TEXT1_PREFIX=Пример 1:
RSHELL_COMMAND_DOCUMENTATION_STRING_REPLACE_TEXT2=строка.заменить 'результат' 'красный, зеленый, синий, красный' 'красный' 'фиолетовый' '0'\n  // В этом примере заменится только одно слово с начала строки ("красный" на "фиолетовый").
RSHELL_COMMAND_DOCUMENTATION_STRING_REPLACE_TEXT3_PREFIX=Пример 2:
RSHELL_COMMAND_DOCUMENTATION_STRING_REPLACE_TEXT4=строка.заменить 'результат' 'красный, зеленый, синий, красный' 'красный' 'фиолетовый' '1'\n  // В этом примере заменятся все слова "красный" на "фиолетовый".

// Команда "СТРОКА.РАЗДЕЛИТЬ".
RSHELL_COMMAND_DOCUMENTATION_STRING_UNUNIT_SYNTAX=строка.разделить '<имя массива, куда запишутся части>' '<строка (текст)>' '<символ>'
RSHELL_COMMAND_DOCUMENTATION_STRING_UNUNIT_DESCRIPTION=Разделяет строку на подстроки (массив).
RSHELL_COMMAND_DOCUMENTATION_STRING_UNUNIT_EXAMPLE=строка.разделить 'часть' 'Renux|лучшая|консоль' '|'

// Команда "ПЕР".
RSHELL_COMMAND_DOCUMENTATION_VAR_SYNTAX=пер <имя переменной> <операция> <новое значение>
RSHELL_COMMAND_DOCUMENTATION_VAR_TEXT1_PREFIX=Форматы (обратите внимание, что кавычки обязательны):
RSHELL_COMMAND_DOCUMENTATION_VAR_TEXT2=Стандарт: пер <имя> = <значение>\n  Сложить: пер <имя> += <значение>\n  Вычесть: пер <имя> -= <значение>\n  Умножить: пер <имя> *= <значение>\n  Разделить: пер <имя> /= <значение>\n  Округлить: пер <имя> округлить <кол-во символов после запятой>\n  Показать список переменных: пер список\n  Математическое выражение: пер <имя> мат <выражение>\n  Заменить: пер <имя> заменить '<строка поиска>' '<строка замены>' '<заменить все?(флаг 1-да/0-нет)>'\n  Разделить строку: пер <имя> разделить '<имя массива>' '<разделительный символ>'\n  Срез: пер <имя> срез <индекс символа (начиная с 1)>\n  Обрезать слева: пер <имя> слева <кол-во символов>\n  Обрезать справа: пер <имя> справа <кол-во символов>\n  Получить кол-во символов: пер <имя> длина\n  Преобразует в верхний регистр: пер <имя> вверх\n  Преобразует в нижний регистр: пер <имя> вниз\n  Разделяет имя файла или URL на составные части: пер <имя> путь '<имя массива>'
RSHELL_COMMAND_DOCUMENTATION_VAR_TEXT3=Вы можете "складывать" строки. Нужно чтобы значение переменной не было числом (сделает слияние строк).\nВы можете "вычитать" строки. Нужно чтобы значение переменной не было числом (заменяет вхождения из второго параметра на пустоту).\nВы можете "умножать" строки. Нужно чтобы значение переменной не было числом (сделает слияние строк столько раз, сколько Вам будет нужно).\nВы можете "разделить" строки. Нужно чтобы значение переменной не было числом (запишет в значение переменной количество найденных входений в значении переменной).
RSHELL_COMMAND_DOCUMENTATION_VAR_EXAMPLES=Стандарт: пер переменнаяс = значение переменной с\n  Сложить: пер переменная2 += 10\n  Вычесть: пер переменная3 -= 20\n  Умножить: пер переменная4 *= 3\n  Разделить: пер переменная5 /= 2\n  Округлить: пер переменная6 округлить 0	(округляет полностью)\n  Показать список переменных: пер список\n  Математическое выражение: пер переменная7 мат 50+50/2*3\n  Заменить: пер переменная8 заменить 'привет' 'пока' '1'\n  Разделить строку: пер переменная8 разделить 'массив' ' '\n  Срез: пер переменная8 срез 4\n  Обрезать слева: пер переменная слева 5\n  Обрезать справа: пер переменная справа 5\n  Получить кол-во символов: пер переменная длина\n  Преобразует в верхний регистр: пер переменная вверх\n  Преобразует в нижний регистр: пер переменная вниз\n  Разделяет имя файла или URL на составные части: пер путь_до_файла путь 'части'
RSHELL_COMMAND_INTERNAL_VAR_ROUND_WORD=округлить
RSHELL_COMMAND_INTERNAL_VAR_LIST_WORD=список
RSHELL_COMMAND_INTERNAL_VAR_TEXT1=Renux Shell обновляет некоторые встроенные переменные только тогда, когда в команде содержится '%' (Знак процента).
RSHELL_COMMAND_INTERNAL_VAR_TEXT2=является объектом
RSHELL_COMMAND_INTERNAL_VAR_MATH_WORD=мат
RSHELL_COMMAND_INTERNAL_VAR_SLICE_WORD=срез
RSHELL_COMMAND_INTERNAL_VAR_REPLACE_WORD=заменить
RSHELL_COMMAND_INTERNAL_VAR_UNUNIT_WORD=разделить
RSHELL_COMMAND_INTERNAL_VAR_LEFT_WORD=слева
RSHELL_COMMAND_INTERNAL_VAR_RIGHT_WORD=справа
RSHELL_COMMAND_INTERNAL_VAR_LEN_WORD=длина
RSHELL_COMMAND_INTERNAL_VAR_UPPER_WORD=вверх
RSHELL_COMMAND_INTERNAL_VAR_LOWER_WORD=вниз
RSHELL_COMMAND_INTERNAL_VAR_PATH_WORD=путь
RSHELL_COMMAND_INTERNAL_VAR_PATH_ARRAY_WORD_NAME=имя
RSHELL_COMMAND_INTERNAL_VAR_PATH_ARRAY_WORD_DIR=папка
RSHELL_COMMAND_INTERNAL_VAR_PATH_ARRAY_WORD_EXTENSION=расширение
RSHELL_COMMAND_INTERNAL_VAR_PATH_ARRAY_WORD_NAMENOEXT=имя_без_расширения
RSHELL_COMMAND_INTERNAL_VAR_PATH_ARRAY_WORD_DISK=диск

// Команда "МАССИВ.ОБЪЕДИНИТЬ".
RSHELL_COMMAND_DOCUMENTATION_ARR_UNIT_SYNTAX=массив.объединить '<имя переменной, куда запишется результат>' '<имя массива>' '<объединяющий символ>'
RSHELL_COMMAND_DOCUMENTATION_ARR_UNIT_DESCRIPTION=Объединяет массив с индексами в одну строку.
RSHELL_COMMAND_DOCUMENTATION_ARR_UNIT_EXAMPLE=Из примера предусматривается, что в массиве "массив" содержатся следующие элементы:\n  массив[0] == тест\n  массив[1] == иров\n  массив[2] == ание\n\n  В результате примера переменная "результат" будет равна значению "тестирование".

// Команда "ДЖСОН".
RSHELL_COMMAND_DOCUMENTATION_JSON_SYNTAX=джсон '<переменная, в которую будет записан результат>' '<название переменной с JSON строкой>' '<путь к элементу>'
RSHELL_COMMAND_DOCUMENTATION_JSON_DESCRIPTION=Извлекает строку из строки JSON формата.
RSHELL_COMMAND_DOCUMENTATION_JSON_EXAMPLE=джсон 'результат' 'переменная1' 'response.items.0.id'

// Команда "МЫШЬ.ПЕРЕДВИНУТЬ".
RSHELL_COMMAND_DOCUMENTATION_MOUSE_MOVE_SYNTAX=мышь.передвинуть '<x>' '<y>' '<s>'
RSHELL_COMMAND_DOCUMENTATION_MOUSE_MOVE_DESCRIPTION=Двигает курсор мыши.
RSHELL_COMMAND_DOCUMENTATION_MOUSE_MOVE_TEXT1=Максимальная скорость (третий аргумент): 100
RSHELL_COMMAND_DOCUMENTATION_MOUSE_MOVE_EXAMPLE=мышь.передвинуть '100' '100' '1'

// Команда "НАПЕЧАТАТЬБ".
RSHELL_COMMAND_DOCUMENTATION_WRITEF_SYNTAX=напечататьб <текст>
RSHELL_COMMAND_DOCUMENTATION_WRITEF_DESCRIPTION=Максимально быстро посылает нажатия клавиш и щелчки мыши в активное окно.
RSHELL_COMMAND_DOCUMENTATION_WRITEF_NOTE=Подробнее в справке: Начало работы > Краткий туториал > Эмуляция нажатий
RSHELL_COMMAND_DOCUMENTATION_WRITEF_EXAMPLE=напечататьб Привет, Мир!

// Команда "НАПЕЧАТАТЬ".
RSHELL_COMMAND_DOCUMENTATION_WRITE_SYNTAX=напечатать <текст>
RSHELL_COMMAND_DOCUMENTATION_WRITE_DESCRIPTION=Посылает нажатия клавиш и щелчки мыши в активное окно.
RSHELL_COMMAND_DOCUMENTATION_WRITE_NOTE=Подробнее в справке: Начало работы > Краткий туториал > Эмуляция нажатий
RSHELL_COMMAND_DOCUMENTATION_WRITE_EXAMPLE=напечатать Привет, Мир!

// Команда "КМД".
RSHELL_COMMAND_DOCUMENTATION_CMD_SYNTAX=кмд <команда>
RSHELL_COMMAND_DOCUMENTATION_CMD_DESCRIPTION=Выполнит команду в командной строке.
RSHELL_COMMAND_DOCUMENTATION_CMD_NOTE1=Если в режиме перенаправления вывода (команда ЗВЫВОД):\n  Создает процесс командной строки, в котором вписывает команду. Дожидается выполнения команды, копирует лог и закрывает процесс. После этого записывает весь лог в вывод.
RSHELL_COMMAND_DOCUMENTATION_CMD_NOTE2=Если не в режиме перенаправаления вывода (по-умолчанию):\n  Открывает командную строку с приказом выполнить команду.
RSHELL_COMMAND_DOCUMENTATION_CMD_EXAMPLE=кмд dir

// Команда "ПРОЦЕСС".
RSHELL_COMMAND_DOCUMENTATION_PROCESS_SYNTAX=процесс '<операция>' '<имя процесса/PID>'
RSHELL_COMMAND_DOCUMENTATION_PROCESS_OPERATIONS=Возможные операции:\n  существует - помещает в переменную .консоль.результат идентификатор процесса (PID), если соответствующий процесс существует, иначе 0. Если второй параметр пустой, определяется PID самого скрипта.\n\n  завершить - завершает процесс(-ы). Если процесс(-ы) завершен(-ы) успешно, в .консоль.результат помещается кол-во завершенных процессов. Так как процесс будет завершён внезапно - возможно, с прерыванием его работы в критической точке или с потерей несохранённых данных - этот метод должен использоваться, только если процесс не может быть закрыт путём применения ОКНО.ЗАКРЫТЬ к одному из его окон.\n  ждать - ожидает существования указанного процесса. При обнаружении подходящего процесса в .консоль.результат помещается его идентификатор (PID).\n  ждать.закрытие - ждёт, пока не будут закрыты ВСЕ отвечающие второму параметру процессы. Если все совпадающие процессы завершаются, .консоль.результат устанавливается в 0.\n  заморозить - заморозит процесс по идентификатору процесса (PID) или его имени.\n  разморозить - разморозит процесс по идентификатору процесса (PID) или его имени.\n  список - отображает список активных процессов на момент исполнения команды. Второй параметр игнорируется.
RSHELL_COMMAND_DOCUMENTATION_PROCESS_CONSOLERESULT=Если команда исполнена без ошибок, то переменная изменяет свое значение на "1" (единицу) (искл. операция "существует").
RSHELL_COMMAND_DOCUMENTATION_PROCESS_EXAMPLE=процесс 'существует' 'explorer.exe'
RSHELL_COMMAND_INTERNAL_PROCESS_OPERATION1=существует
RSHELL_COMMAND_INTERNAL_PROCESS_OPERATION2=завершить
RSHELL_COMMAND_INTERNAL_PROCESS_TEXT1=Процесс %1 с идентификатором %2 был успешно завершен.
RSHELL_COMMAND_INTERNAL_PROCESS_TEXT2=Процесс %1 с идентификатором %2 завершить не удалось.
RSHELL_COMMAND_INTERNAL_PROCESS_TEXT3=Всего процессов было завершено: %1.
RSHELL_COMMAND_INTERNAL_PROCESS_OPERATION3=ждать
RSHELL_COMMAND_INTERNAL_PROCESS_OPERATION4=ждать.закрытие
RSHELL_COMMAND_INTERNAL_PROCESS_OPERATION5=заморозить
RSHELL_COMMAND_INTERNAL_PROCESS_OPERATION6=разморозить
RSHELL_COMMAND_INTERNAL_PROCESS_OPERATION7=список
RSHELL_COMMAND_INTERNAL_PROCESS_TEXT4=Без имени
RSHELL_COMMAND_INTERNAL_PROCESS_TEXT5=Описание
RSHELL_COMMAND_INTERNAL_PROCESS_TEXT6=Идентификатор
RSHELL_COMMAND_INTERNAL_PROCESS_TEXT7=Путь к файлу
RSHELL_COMMAND_INTERNAL_PROCESS_TEXT8=Копирайт
RSHELL_COMMAND_INTERNAL_PROCESS_TEXT9=Всего процессов: %1.
RSHELL_COMMAND_INTERNAL_PROCESS_TEXT10=Ошибка в синтаксисе команды.

// Команда "ПШ".
RSHELL_COMMAND_DOCUMENTATION_PSH_SYNTAX=пш <команда>
RSHELL_COMMAND_DOCUMENTATION_PSH_DESCRIPTION=Выполнит команду в PowerShell.
RSHELL_COMMAND_DOCUMENTATION_PSH_TEXT1=Если в режиме перенаправления вывода (команда ЗВЫВОД):\n  Создает процесс командной строки, в котором вписывает команду. Дожидается выполнения команды, копирует лог и закрывает процесс. После этого записывает весь лог в вывод.
RSHELL_COMMAND_DOCUMENTATION_PSH_TEXT2=Если не в режиме перенаправаления вывода (по-умолчанию):\n  Открывает командную строку с приказом выполнить команду.
RSHELL_COMMAND_DOCUMENTATION_PSH_EXAMPLE=пш dir

// Команда "РЕСТАРТ".
RSHELL_COMMAND_DOCUMENTATION_RESTART_SYNTAX=рестарт
RSHELL_COMMAND_DOCUMENTATION_RESTART_DESCRIPTION=Перезапустит Renux Shell.

// Команда "ОКНО.ЭЛЕМЕНТ".
RSHELL_COMMAND_DOCUMENTATION_WIN_ELEM_SYNTAX=окно.элемент
RSHELL_COMMAND_DOCUMENTATION_WIN_ELEM_DESCRIPTION=Получить информацию о элементе окна.
RSHELL_COMMAND_INTERNAL_WIN_ELEM_TEXT1=Нажмите ПКМ на элемент для показа информации.
RSHELL_COMMAND_INTERNAL_WIN_ELEM_TEXT2=Имя элемента
RSHELL_COMMAND_INTERNAL_WIN_ELEM_TEXT3=Позиция
RSHELL_COMMAND_INTERNAL_WIN_ELEM_TEXT4=Заголовок окна

// Команда "ОКНО.ЭЛЕМЕНТ.ПЕРЕДВИНУТЬ".
RSHELL_COMMAND_DOCUMENTATION_WIN_ELEM_MOVE_SYNTAX=окно.элемент.передвинуть '<имя элемента>' '<заголовок окна/его часть>' '<x>' '<y>' '<w>' '<h>'
RSHELL_COMMAND_DOCUMENTATION_WIN_ELEM_MOVE_DESCRIPTION=Изменит положение элемента окна с указанным заголовком.
RSHELL_COMMAND_DOCUMENTATION_WIN_ELEM_MOVE_EXAMPLE=окно.элемент.передвинуть 'Static1' 'Блокнот: сведения' '100' '100' '100' '100'

// Команда "ОКНО.ЭЛЕМЕНТ.ЗНАЧЕНИЕ".
RSHELL_COMMAND_DOCUMENTATION_WIN_ELEM_VALUE_SYNTAX=окно.элемент.значение '<имя элемента>' '<заголовок окна/его часть>' '<новое значение>'
RSHELL_COMMAND_DOCUMENTATION_WIN_ELEM_VALUE_DESCRIPTION=Изменит значение элемента окна с указанным заголовком.
RSHELL_COMMAND_DOCUMENTATION_WIN_ELEM_VALUE_EXAMPLE=окно.элемент.значение 'Static1' 'Блокнот: сведения' 'RENUX ДЕМОНСТРАЦИЯ'

// Команда "ОКНО.ЭЛЕМЕНТ.НАПЕЧАТАТЬ".
RSHELL_COMMAND_DOCUMENTATION_WIN_ELEM_WRITE_SYNTAX=окно.элемент.напечатать '[имя элемента]' '<заголовок окна/его часть>' '<текст>'
RSHELL_COMMAND_DOCUMENTATION_WIN_ELEM_WRITE_DESCRIPTION=Имитирует нажатия клавиш в окно или его элемент.
RSHELL_COMMAND_DOCUMENTATION_WIN_ELEM_WRITE_TEXT1=Пример 1:\n  окно.элемент.напечатать '' 'Документ - WordPad' 'Тестовое сообщение'
RSHELL_COMMAND_DOCUMENTATION_WIN_ELEM_WRITE_TEXT2=Пример 2:\n  окно.элемент.напечатать 'Edit1' 'Безымянный – Блокнот' 'Тестовое сообщение'

// Пакетные файлы...
RSHELL_SHELL_MODE_TEXT1=Обработано %1 строк кода.
RSHELL_SHELL_MODE_TEXT2=Оптимизированный код
RSHELL_SHELL_MODE_TEXT3=Оптимизированный код функции
RSHELL_SHELL_MODE_TEXT4=Активирована горячая клавиша '%1'! Переход на строку #%2 успешен.
RSHELL_SHELL_MODE_TEXT5=Сценарий завершен.

// Команда "ЕСЛИ".
RSHELL_COMMAND_INTERNAL_IF_PARSE_WORD=то
RSHELL_COMMAND_DOCUMENTATION_IF_TEXT1=Формат:\n	"==": если '<текст>' == '<текст>' то <команда, которая будет выполнена>\n	"!=": если '<текст>' != '<текст>' то <команда, которая будет выполнена>\n	">": если '<число>' > '<число>' то <команда, которая будет выполнена>\n	"<": если '<число>' < '<число>' то <команда, которая будет выполнена>\n	">=": если '<число>' >= '<число>' то <команда, которая будет выполнена>\n	"=<": если '<число>' =< '<число>' то <команда, которая будет выполнена>\n	"содержит": если '<текст>' содержит '<текст>' то <команда, которая будет выполнена>\n	"не содержит": если '<текст>' несодержит '<текст>' то <команда, которая будет выполнена>\n	"файл существует": если 'файл' существует '<путь к файлу>' то <команда, которая будет выполнена>\n	"файл не существует": если 'файл' несуществует '<путь к файлу>' то <команда, которая будет выполнена>\n	"переменная существует": если 'переменная' существует '<имя переменной/индекс массива>' то <команда, которая будет выполнена>\n	"переменная не существует": если 'переменная' несуществует '<имя переменной/индекс массив>' то <команда, которая будет выполнена>\nПример:\n	"==": если '`%пер`%' == '1' то вывод Переменная ПЕР равна единице.\n	"!=": если 'привет' != 'пока' то вывод Слово "привет" не равно слову "пока".\n	">": если '40' > '5' то вывод 40 больше 5.\n	"<": если '`%пер`%' < '5' то вывод Переменная ПЕР меньше 5.\n	">=": если '`%пер1`%' >= '5' то вывод Переменная ПЕР1 больше или равна пяти.\n	"=<": если '4' =< '5' то вывод 4 меньше или равно 5.\n	"содержит": если 'какой-то текст, который записан в переменной' содержит 'текст' то вывод Найдено слово 'текст'.\n	"не содержит": если '`%текст`%' несодержит 'какую-то строку' то вывод Переменная ТЕКСТ не содержит "какую-то строку".\n	"файл существует": если 'файл' существует 'C:\test.txt' то вывод Файл по пути C:\test.txt существует.\n	"файл не существует": если 'файл' несуществует 'C:\test.txt' то Файла по пути C:\test.txt не существует.\n	"переменная существует": если 'переменная' cуществует 'тестовая_переменная' то вывод Переменная "тестовая_переменная" существует.\n	"переменная не существует": если 'переменная' несуществует 'информация[1]' то вывод Массив под именем "информация" с индексом "1" не существует.
RSHELL_COMMAND_INTERNAL_IF_TEXT1=Ожидался символ: '.
RSHELL_COMMAND_INTERNAL_IF_TEXT2=существует
RSHELL_COMMAND_INTERNAL_IF_TEXT3=файл
RSHELL_COMMAND_INTERNAL_IF_TEXT4=переменная
RSHELL_COMMAND_INTERNAL_IF_TEXT5=несуществует
RSHELL_COMMAND_INTERNAL_IF_TEXT6=переменная
RSHELL_COMMAND_INTERNAL_IF_TEXT7=содержит
RSHELL_COMMAND_INTERNAL_IF_TEXT8=несодержит
RSHELL_COMMAND_INTERNAL_IF_TEXT9=Вы указали недопустимые параметры. Возможно, Вы указали команду не по формату.

// Команда "ФАЙЛ.СОЗДАТЬ.ЯРЛЫК".
RSHELL_COMMAND_DOCUMENTATION_FILE_ADD_LABEL_SYNTAX=файл.создать.ярлык '<путь к файлу (который будет активироваться)>' '<путь к файлу (куда записать)>' '[рабочая папка]' '[параметры]' '[описание]' '[путь к иконке]' '[горячие клавиши]' '[номер значка]' '[стартовое состояние]'
RSHELL_COMMAND_DOCUMENTATION_FILE_ADD_LABEL_NOTE=рабочая папка = Папка, которая будет текущим рабочим каталогом для целевого файла при запуске ярлыка. Если параметр пустой, поле "Рабочая папка" в свойствах ярлыка будет пустым и операционная система будет предоставлять при запуске ярлыка рабочую папку по умолчанию.\nпараметры = Параметры для передачи целевому файлу при запуске. Разделяйте параметры пробелами. Если параметр содержит в себе пробелы, заключайте его в двойные кавычки.\nописание = Комментарии, описывающие ярлык (используются операционной системой для показа всплывающих подсказок и т.п.).\nпуть к иконке = Полный путь и имя значка, который будет использован для ярлыка. Может быть файлом в формате ICO либо самым первым значком в файле EXE или DLL.\nгорячие клавиши = Горячая клавиша для ярлыка. Одиночная буква, цифра или имя клавиши (кнопки мыши и другие нестандартные клавиши могут не поддерживаться). В настоящее время все горячие клавиши создаются как комбинации с CTRL+ALT. Например, при указании буквы В горячая клавиша будет CTRL-ALT-B.\nномер значка = Номер значка в файле со значками (если используется не первый). Может быть выражением. Например, 2 означает второй значок.\nстартовое состояние = Для запуска в свёрнутом или развёрнутом окне укажите одну из следующих цифр: 1 - нормальное окно (по умолчанию); 3 - развёрнутое; 7 - свёрнутое.
RSHELL_COMMAND_DOCUMENTATION_FILE_ADD_LABEL_EXAMPLE=файл.создать.ярлык 'C:\test.exe' 'test.lnk'

// Команда "ЦИКЛ".
RSHELL_COMMAND_DOCUMENTATION_LOOP_SYNTAX=цикл [кол-во повторов:] <команда>
RSHELL_COMMAND_DOCUMENTATION_LOOP_NOTE=Если первый параметр опущен, то цикл выполняется бесконечно.
RSHELL_COMMAND_DOCUMENTATION_LOOP_TEXT1=Пример с определенным количеством повторов:\n  цикл 5: вывод Это сообщение выводится 5 раз
RSHELL_COMMAND_DOCUMENTATION_LOOP_TEXT2=Пример с бесконечным количеством повторов:\n  цикл вывод Это сообщение выводится бесконечно, пока Вы не закроете это окно.

// Команда "ДЛЯ".
RSHELL_COMMAND_DOCUMENTATION_FOR_SYNTAX=для <вывод ключа> <вывод значения> в <вывод массива>
RSHELL_COMMAND_DOCUMENTATION_FOR_EXAMPLE=для ключ значение в массив сделать вывод Ключ: %ключ%`nЗначение: %значение%
RSHELL_COMMAND_INTERNAL_FOR_TEXT1=Некорректный синтаксис команды.
RSHELL_COMMAND_INTERNAL_FOR_PARSE_WORD=в
RSHELL_COMMAND_INTERNAL_FOR_PARSE_WORD_DO=сделать
RSHELL_COMMAND_INTERNAL_FOR_TEXT2=Укажите допустимое значение переменной для вывода.
RSHELL_COMMAND_INTERNAL_FOR_TEXT3=Укажите допустимое значение массива.
RSHELL_COMMAND_INTERNAL_FOR_TEXT4=Укажите параметр '<команда>'.
RSHELL_COMMAND_INTERNAL_FOR_TEXT5=Укажите имя массива без индекса.

// Служба "ЯЗЫК.СМЕНА".
RSHELL_SERVICE_LANG_CHANGE_NAME=ЯЗЫК.СМЕНА
RSHELL_SERVICE_LANG_CHANGE_DESCRIPTION=Служба установки альтернативного файла локализации.
RSHELL_SERVICE_LANG_CHANGE_STARTED_TEXT=Запущена служба установки альтернативного файла локализации.
RSHELL_SERVICE_LANG_CHANGE_TEXT1=Список доступных файлов локализации:
RSHELL_SERVICE_LANG_CHANGE_TEXT2=Язык
RSHELL_SERVICE_LANG_CHANGE_TEXT3=Укажите порядковый номер языка, чтобы его применить:
RSHELL_SERVICE_LANG_CHANGE_TEXT4=Применение языка %1...
RSHELL_SERVICE_LANG_CHANGE_TEXT5=Язык с таким именем не найден.
RSHELL_SERVICE_LANG_CHANGE_TEXT6=Язык успешно применен. Стартовая команда была изменена на совместимую и стандартную для этой локализации.
RSHELL_SERVICE_LANG_CHANGE_TEXT7=Текущий язык: %1.

// Version 2.18.1:
RSHELL_UPDINFO_2_18_1=- Исправлены ошибки локализации в команде "ПРОГ".

// Version 2.19:
RSHELL_UPDINFO_2_19=- Мелкие фиксы и улучшения.\n- Появилась английская локализация.